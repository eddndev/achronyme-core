// =============================================================================
// Example 43: Generator as Static Type
// Demonstrates Generator type annotations (opaque, no yield type parameterization)
// =============================================================================

print("=== Generator Type Annotations ===")
print("")

// -----------------------------------------------------------------------------
// Part 1: Basic Generator Type Annotation
// -----------------------------------------------------------------------------
print("--- Part 1: Basic Generator Type ---")

// Define a type alias for Generator
type NumberSequence = Generator

// Function that returns a generator
let createCounter: () => Generator = () => generate {
    yield 1
    yield 2
    yield 3
}

let counter: Generator = createCounter()
print("Counter type: Generator")
print("First value: " + str(counter.next().value))
print("Second value: " + str(counter.next().value))
print("Third value: " + str(counter.next().value))

print("")

// -----------------------------------------------------------------------------
// Part 2: Generator Type Alias
// -----------------------------------------------------------------------------
print("--- Part 2: Generator Type Aliases ---")

// Type aliases for semantic clarity
type DataStream = Generator
type LazySequence = Generator

let fibGenerator: () => LazySequence = () => generate {
    let a = 0
    let b = 1
    yield a
    yield b

    // Generate next few fibonacci numbers
    let c = a + b
    yield c
    let d = b + c
    yield d
    let e = c + d
    yield e
}

let fibs: LazySequence = fibGenerator()
print("Fibonacci generator (type: LazySequence):")
print("  F(0) = " + str(fibs.next().value))
print("  F(1) = " + str(fibs.next().value))
print("  F(2) = " + str(fibs.next().value))
print("  F(3) = " + str(fibs.next().value))
print("  F(4) = " + str(fibs.next().value))

print("")

// -----------------------------------------------------------------------------
// Part 3: Functions that Accept Generators
// -----------------------------------------------------------------------------
print("--- Part 3: Functions Accepting Generators ---")

// Function that takes a generator and collects values
// Demonstrates using Generator type in parameters
let takeThree: (Generator) => Vector = (gen) => do {
    let v1 = gen.next().value
    let v2 = gen.next().value
    let v3 = gen.next().value
    [v1, v2, v3]
}

// Create a generator for testing
let rangeGen = () => generate {
    yield 10
    yield 20
    yield 30
    yield 40
    yield 50
}

let gen1 = rangeGen()
let first3 = takeThree(gen1)
print("Collect first 3 from generator: " + str(first3))

// Manual collection from another generator
let gen2 = rangeGen()
print("Fourth value (after taking 3): " + str(gen2.next().value))
print("Fifth value: " + str(gen2.next().value))

print("")

// -----------------------------------------------------------------------------
// Part 4: Generator Union Types
// -----------------------------------------------------------------------------
print("--- Part 4: Generator with Union Types ---")

// Generator can be part of union types
type MaybeGenerator = Generator | null

// Create generator instances (call the generator function!)
let createGen = () => generate { yield "data" }
let gen3: MaybeGenerator = createGen()  // Instance, not function
let gen4: MaybeGenerator = null

print("Optional generator (assigned): " + typeof(gen3))
print("Optional generator (null): " + str(gen4))

// Type alias demonstrates semantic meaning
type Iterator = Generator
let createIter = () => generate {
    yield "a"
    yield "b"
}
let myIter: Iterator = createIter()  // Instance
print("Iterator alias works: " + typeof(myIter))

print("")

// -----------------------------------------------------------------------------
// Part 5: Record with Generator Field
// -----------------------------------------------------------------------------
print("--- Part 5: Records with Generator Fields ---")

type StreamConfig = {
    name: String,
    source: Generator
}

let dataSource = () => generate {
    yield { timestamp: 0, value: 100 }
    yield { timestamp: 1, value: 150 }
    yield { timestamp: 2, value: 125 }
}

let config: StreamConfig = {
    name: "SensorA",
    source: dataSource()
}

print("Stream config name: " + config.name)
print("Stream type: " + typeof(config.source))

let reading = config.source.next().value
print("First reading: timestamp=" + str(reading.timestamp) + ", value=" + str(reading.value))

print("")

// -----------------------------------------------------------------------------
// Part 6: Type Checking at Runtime
// -----------------------------------------------------------------------------
print("--- Part 6: Runtime Type Checking ---")

let checkType = (value) => do {
    let t = typeof(value)
    print("  " + str(value) + " has type: " + t)
}

print("Type checks:")
checkType(42)
checkType("hello")
checkType(() => generate { yield 1 })

// Verify generator is identified correctly
let myGen = () => generate { yield "test" }
print("typeof(generator function): " + typeof(myGen))
print("typeof(generator instance): " + typeof(myGen()))

print("")

// -----------------------------------------------------------------------------
// Summary
// -----------------------------------------------------------------------------
print("=== Summary ===")
print("Generator is now a first-class type in the type system:")
print("1. Can be used in variable type annotations")
print("2. Can be used in function return types")
print("3. Can be used in function parameter types")
print("4. Can be part of union types (Generator | null)")
print("5. Can be used in record field types")
print("6. Type aliases can reference Generator type")
print("")
print("Note: Generator is currently opaque (no Generator<T> parameterization)")
print("This means yield type is not statically verified.")
print("Future: Generator<Number> for typed generators")
