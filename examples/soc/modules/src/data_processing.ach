// ============================================================================
// Data Processing Utilities Module
// ============================================================================
// This module provides utility functions for data processing, cleaning,
// and transformation. It demonstrates how to create reusable utility
// modules in Achronyme.
//
// NOTE: User-defined modules with export are not yet implemented in Phase 2/3.
// This file serves as a design example for when export functionality is added.
// ============================================================================

import { mean, std } from "stats"
import { sqrt } from "math"

// Export functions (syntax ready for Phase 4)
// export { loadData, filterOutliers, normalize, rescale, detectOutliers }

// ============================================================================
// Data Loading and Parsing
// ============================================================================

// Load data from various sources
let loadData = dataSource => {
    // In a real implementation, this would:
    // - Read from files (CSV, JSON, etc.)
    // - Parse strings to numbers
    // - Handle missing values
    // - Validate data format

    // For now, just return the data as-is
    dataSource
}

// Parse CSV string to array of numbers
let parseCSV = csvString => {
    // Split by comma and convert to numbers
    let parts = split(csvString, ",")
    map(str => {
        // Simple string to number conversion
        // In real implementation, use proper parsing
        str
    }, parts)
}

// ============================================================================
// Outlier Detection and Filtering
// ============================================================================

// Detect outliers using IQR (Interquartile Range) method
let detectOutliersIQR = data => {
    let sorted = data  // Should sort first
    let n = len(sorted)

    // Calculate Q1, Q2, Q3 (simplified - assumes sorted)
    let q1Index = floor(n * 0.25)
    let q3Index = floor(n * 0.75)

    let q1 = sorted[q1Index]
    let q3 = sorted[q3Index]
    let iqr = q3 - q1

    let lowerFence = q1 - 1.5 * iqr
    let upperFence = q3 + 1.5 * iqr

    // Return outlier information
    {
        lowerFence: lowerFence,
        upperFence: upperFence,
        outliers: filter(x => x < lowerFence || x > upperFence, data)
    }
}

// Detect outliers using Z-score method
let detectOutliersZScore = (data, threshold) => {
    let dataMean = mean(data)
    let dataStd = std(data)

    let zScores = map(x => (x - dataMean) / dataStd, data)

    let outlierIndices = []
    let outlierValues = []

    // Find indices where |z-score| > threshold
    filter(x => abs(x) > threshold, zScores)
}

// Remove outliers from dataset
let filterOutliers = (data, method, threshold) => {
    if (method == "zscore") {
        let dataMean = mean(data)
        let dataStd = std(data)
        let lowerBound = dataMean - threshold * dataStd
        let upperBound = dataMean + threshold * dataStd

        filter(x => x >= lowerBound && x <= upperBound, data)
    } else {
        // Default: IQR method
        let outlierInfo = detectOutliersIQR(data)
        filter(
            x => x >= outlierInfo.lowerFence && x <= outlierInfo.upperFence,
            data
        )
    }
}

// ============================================================================
// Data Normalization and Scaling
// ============================================================================

// Z-score normalization (standardization)
// Transforms data to have mean=0 and std=1
let normalize = data => {
    let dataMean = mean(data)
    let dataStd = std(data)

    map(x => (x - dataMean) / dataStd, data)
}

// Min-Max scaling to range [0, 1]
let rescale = (data, newMin, newMax) => {
    let dataMin = min(data)
    let dataMax = max(data)
    let range = dataMax - dataMin

    map(
        x => newMin + ((x - dataMin) / range) * (newMax - newMin),
        data
    )
}

// Robust scaling (using median and IQR)
let robustScale = data => {
    let sorted = data  // Should sort first
    let n = len(sorted)
    let medianIndex = floor(n / 2)
    let dataMedian = sorted[medianIndex]

    // Calculate IQR (simplified)
    let q1Index = floor(n * 0.25)
    let q3Index = floor(n * 0.75)
    let iqr = sorted[q3Index] - sorted[q1Index]

    map(x => (x - dataMedian) / iqr, data)
}

// ============================================================================
// Data Transformation
// ============================================================================

// Log transformation (useful for skewed data)
let logTransform = data => {
    // Add small constant to avoid log(0)
    let epsilon = 1e-10
    map(x => ln(x + epsilon), data)
}

// Square root transformation
let sqrtTransform = data => {
    map(x => sqrt(abs(x)), data)
}

// Power transformation
let powerTransform = (data, power) => {
    map(x => pow(x, power), data)
}

// ============================================================================
// Data Validation
// ============================================================================

// Check for missing values (NaN, null, etc.)
let hasMissingValues = data => {
    // In Achronyme, all values should be valid
    // This is a placeholder for when we have NaN support
    false
}

// Check if data is within valid range
let validateRange = (data, minVal, maxVal) => {
    all(x => x >= minVal && x <= maxVal, data)
}

// Check if data contains only positive values
let allPositive = data => {
    all(x => x > 0, data)
}

// ============================================================================
// Data Statistics and Properties
// ============================================================================

// Calculate coefficient of variation (CV)
// CV = (std / mean) * 100%
let coefficientOfVariation = data => {
    let dataMean = mean(data)
    let dataStd = std(data)
    (dataStd / dataMean) * 100
}

// Calculate skewness (measure of asymmetry)
let skewness = data => {
    let dataMean = mean(data)
    let dataStd = std(data)
    let n = len(data)

    let sumCubed = sum(
        map(x => pow((x - dataMean) / dataStd, 3), data)
    )

    sumCubed / n
}

// Calculate kurtosis (measure of tailedness)
let kurtosis = data => {
    let dataMean = mean(data)
    let dataStd = std(data)
    let n = len(data)

    let sumFourth = sum(
        map(x => pow((x - dataMean) / dataStd, 4), data)
    )

    (sumFourth / n) - 3  // Excess kurtosis
}

// ============================================================================
// Example Usage
// ============================================================================

print("Data Processing Utilities Module Loaded")
print("Available functions:")
print("  - loadData, parseCSV")
print("  - detectOutliersIQR, detectOutliersZScore, filterOutliers")
print("  - normalize, rescale, robustScale")
print("  - logTransform, sqrtTransform, powerTransform")
print("  - validateRange, allPositive, hasMissingValues")
print("  - coefficientOfVariation, skewness, kurtosis")
print("")

// Example: Process a sample dataset
let sampleData = [10, 12, 15, 14, 13, 16, 11, 14, 15, 100]  // Note: 100 is an outlier

print("Sample Data:", sampleData)
print("Mean:", mean(sampleData))
print("Std:", std(sampleData))

// Remove outliers
let cleanData = filterOutliers(sampleData, "zscore", 2.5)
print("After removing outliers:", cleanData)
print("Clean data mean:", mean(cleanData))

// Normalize
let normalizedData = normalize(cleanData)
print("Normalized data (first 3):", [normalizedData[0], normalizedData[1], normalizedData[2]])

// Rescale to [0, 1]
let scaledData = rescale(cleanData, 0, 1)
print("Scaled to [0,1] (first 3):", [scaledData[0], scaledData[1], scaledData[2]])
