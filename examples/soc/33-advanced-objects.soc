// ============================================================================
// Example 33: Advanced Object-Oriented Programming with Self & Rec
// ============================================================================
// Demonstrates:
// - Records with methods using 'self' for object-oriented programming
// - Recursive methods within objects using 'self'
// - IIFE (Immediately Invoked Function Expressions) with 'rec'
// - Method chaining and composition
// - Getters with zero-parameter lambdas
// ============================================================================

// Example 1: Mathematical Calculator Object
// ------------------------------------------
let calculator = {
    // State
    precision: 6,

    // Recursive factorial using self
    factorial: n => if(n <= 1, 1, n * self.factorial(n - 1)),

    // Fibonacci using self recursion
    fibonacci: n => if(n <= 1, n, self.fibonacci(n - 1) + self.fibonacci(n - 2)),

    // Method that uses another method
    factorialSum: n => self.factorial(n) + self.fibonacci(n),

    // Getter using zero-parameter lambda
    getPrecision: () => self.precision
}

let result1 = calculator.factorial(5)        // 120
let result2 = calculator.fibonacci(6)        // 8
let result3 = calculator.factorialSum(4)     // 24 + 3 = 27
let result4 = calculator.getPrecision()      // 6


// Example 2: Statistics Object with Method Composition
// -----------------------------------------------------
let stats = {
    data: [10, 20, 30, 40, 50],

    // Get data using getter
    getData: () => self.data,

    // Sum using built-in
    sum: () => sum(self.data),

    // Mean using method composition
    mean: () => self.sum() / 5,

    // Calculate variance
    variance: () => (
        mu => sum(map(x => (x - mu) * (x - mu), self.data)) / 5
    )(self.mean()),

    // Standard deviation
    stdDev: () => sqrt(self.variance())
}

let dataSet = stats.getData()       // [10, 20, 30, 40, 50]
let total = stats.sum()              // 150
let average = stats.mean()           // 30
let variance = stats.variance()      // 200


// Example 3: Vector Factory using IIFE
// --------------------------------------------
let vectorFactory = {
    // Create a vector object using IIFE
    create: (x, y, z) => (
        components => {
            x: components[0],
            y: components[1],
            z: components[2],

            // Magnitude using self
            magnitude: () => sqrt(
                self.x * self.x +
                self.y * self.y +
                self.z * self.z
            ),

            // Dot product with another vector
            dot: other => (
                self.x * other.x +
                self.y * other.y +
                self.z * other.z
            )
        }
    )([x, y, z])
}

let vec1 = vectorFactory.create(3, 4, 0)
let mag = vec1.magnitude()           // 5.0
let vec2 = vectorFactory.create(1, 0, 0)
let dotProduct = vec1.dot(vec2)      // 3.0


// Example 4: Object with Recursive Methods
// -----------------------------------------
let fibonacci = {
    // Compute fibonacci using rec
    compute: n => if(n <= 1, n, rec(n - 1) + rec(n - 2)),

    // Generate sequence using map and self
    sequence: n => map(i => self.compute(i), [0, 1, 2, 3, 4, 5])
}

let fib5 = fibonacci.compute(5)             // 5
let fibSeq = fibonacci.sequence(6)          // [0, 1, 1, 2, 3, 5]


// Example 5: Nested Objects
// --------------------------
let mathLibrary = {
    constants: {
        pi: 3.14159,
        e: 2.71828,
        getPi: () => self.pi
    },

    operations: {
        circleArea: r => 3.14159 * r * r,
        sphereVolume: r => (4.0 / 3.0) * 3.14159 * r * r * r
    }
}

let piValue = mathLibrary.constants.getPi()           // 3.14159
let area = mathLibrary.operations.circleArea(5)       // ~78.54


// Example 6: Object with IIFE for Inline Computation
// ---------------------------------------------------
let processor = {
    data: [1, 2, 3, 4, 5],

    // Process data with inline recursive function using IIFE
    processWithIIFE: () => (
        factorial => map(factorial, self.data)
    )(
        n => if(n <= 1, 1, n * rec(n - 1))
    ),

    // Alternative: direct method
    processDirect: () => map(n => if(n <= 1, 1, n * rec(n - 1)), self.data)
}

let processed1 = processor.processWithIIFE()    // [1, 2, 6, 24, 120]
let processed2 = processor.processDirect()      // [1, 2, 6, 24, 120]


// Example 7: Complex Method Chaining
// -----------------------------------
let dataAnalyzer = {
    rawData: [5, 10, 15, 20, 25],

    // Filter even numbers
    filterEven: () => filter(x => x % 2 == 0, self.rawData),

    // Double all values
    double: () => map(x => x * 2, self.rawData),

    // Get stats
    getStats: () => {
        sum: sum(self.rawData),
        mean: sum(self.rawData) / 5,
        count: 5
    }
}

let evenNums = dataAnalyzer.filterEven()        // [10, 20]
let doubled = dataAnalyzer.double()             // [10, 20, 30, 40, 50]
let statistics = dataAnalyzer.getStats()        // {sum: 75, mean: 15, count: 5}


// Summary Output
// --------------
result1              // 120 - factorial(5)
result2              // 8 - fibonacci(6)
average              // 30 - mean
mag                  // 5.0 - vector magnitude
fib5                 // 5 - fibonacci(5)
piValue              // 3.14159
