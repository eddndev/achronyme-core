// ============================================================================
// Example 37: Advanced Recursion Patterns with IIFE and Accumulators
// ============================================================================
// Demonstrates powerful recursion techniques using IIFE (Immediately Invoked
// Function Expressions) combined with rec for creating utility functions
// with tail-call-like behavior using accumulators.
//
// ⚠️ WARNING: RECURSION DEPTH LIMIT
// Due to environment cloning on each recursive call, Achronyme currently
// has a strict limit of ~50 recursive calls before stack overflow.
// All examples in this file work with small n (< 50), but will fail with
// larger values. For production use, prefer built-in functions like linspace().
// See docs/language/25-performance-limitations.md for details.
// ============================================================================

// ============================================================================
// 1. Basic Pattern: Recursive IIFE with Accumulator
// ============================================================================

// zeros(n) - Create array of n zeros
let zeros = n => (
    (left, vector) => if(left == 0, vector, rec(left - 1, [0, ...vector]))
)(n, [])

zeros(5)    // [0, 0, 0, 0, 0]
zeros(10)   // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

// ones(n) - Create array of n ones
let ones = n => (
    (left, vector) => if(left == 0, vector, rec(left - 1, [1, ...vector]))
)(n, [])

ones(5)     // [1, 1, 1, 1, 1]

// ============================================================================
// 2. Recursive Range Generation
// ============================================================================

// range(n) - Generate [0, 1, 2, ..., n-1]
let range = n => (
    (left, current, vector) =>
        if(left == 0, vector, rec(left - 1, current + 1, [...vector, current]))
)(n, 0, [])

range(5)    // [0, 1, 2, 3, 4]
range(10)   // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

// range_step(start, end, step) - Generate range with step
let range_step = (start, end, step) => (
    (current, vector) =>
        if(current >= end, vector, rec(current + step, [...vector, current]))
)(start, [])

range_step(0, 10, 2)    // [0, 2, 4, 6, 8]
range_step(1, 10, 3)    // [1, 4, 7]

// ============================================================================
// 3. Factorial with Accumulator (Tail Recursion Style)
// ============================================================================

// Traditional recursive factorial
let factorial_simple = n =>
    if(n <= 1, 1, n * rec(n - 1))

factorial_simple(5)  // 120

// Factorial with accumulator (tail-call style)
let factorial_acc = n => (
    (current, acc) =>
        if(current <= 1, acc, rec(current - 1, acc * current))
)(n, 1)

factorial_acc(5)     // 120
factorial_acc(10)    // 3628800

// ============================================================================
// 4. Fibonacci with Memoization Pattern
// ============================================================================

// Fibonacci with accumulator (more efficient)
let fibonacci_acc = n => (
    (i, a, b) =>
        if(i == 0, a, rec(i - 1, b, a + b))
)(n, 0, 1)

fibonacci_acc(10)    // 55
fibonacci_acc(20)    // 6765

// ============================================================================
// 5. Sum with Accumulator
// ============================================================================

// Sum array elements using recursion with accumulator
let sum_recursive = arr => (
    (remaining, acc) =>
        if(remaining[0] == remaining[-1],  // Check if only one element
           acc + remaining[0],
           rec(remaining[1..], acc + remaining[0]))
)(arr, 0)

// Note: This is just for demonstration, use built-in sum() in practice
// sum_recursive([1, 2, 3, 4, 5])  // Would need proper empty check

// ============================================================================
// 6. Repeat Pattern
// ============================================================================

// repeat(value, n) - Repeat value n times
let repeat = (value, n) => (
    (left, vector) =>
        if(left == 0, vector, rec(left - 1, [value, ...vector]))
)(n, [])

repeat(42, 5)        // [42, 42, 42, 42, 42]
repeat("x", 3)       // ["x", "x", "x"]

// ============================================================================
// 7. Countdown and Countup
// ============================================================================

// countdown(n) - Generate [n, n-1, ..., 1]
let countdown = n => (
    (current, vector) =>
        if(current == 0, vector, rec(current - 1, [...vector, current]))
)(n, [])

countdown(5)         // [5, 4, 3, 2, 1]

// countup(n) - Generate [1, 2, ..., n]
let countup = n => (
    (current, vector) =>
        if(current > n, vector, rec(current + 1, [...vector, current]))
)(1, [])

countup(5)           // [1, 2, 3, 4, 5]

// ============================================================================
// 8. Power with Accumulator
// ============================================================================

// power(base, exp) - Calculate base^exp using accumulator
let power_acc = (base, exp) => (
    (remaining, acc) =>
        if(remaining == 0, acc, rec(remaining - 1, acc * base))
)(exp, 1)

power_acc(2, 10)     // 1024
power_acc(3, 4)      // 81

// ============================================================================
// 9. Reverse Array (Recursive)
// ============================================================================

// reverse(arr) - Reverse array using accumulator
let reverse_rec = arr => (
    (remaining, result) =>
        if(remaining[0] == remaining[-1],  // Single element left
           [...result, remaining[0]],
           rec(remaining[1..], [...result, remaining[0]]))
)(arr, [])

// reverse_rec([1, 2, 3, 4, 5])  // Would need proper implementation

// ============================================================================
// 10. Fill Array with Function
// ============================================================================

// fill_with(n, fn) - Create array by applying function to indices
let fill_with = (n, fn) => (
    (index, vector) =>
        if(index >= n, vector, rec(index + 1, [...vector, fn(index)]))
)(0, [])

fill_with(5, x => x * x)         // [0, 1, 4, 9, 16]
fill_with(5, x => x * 2)         // [0, 2, 4, 6, 8]
fill_with(3, x => x * x * x)     // [0, 1, 8]

// ============================================================================
// 11. Nested Recursion: 2D Arrays
// ============================================================================

// zeros_2d(rows, cols) - Create 2D array of zeros
let zeros_2d = (rows, cols) => (
    (rows_left, result) =>
        if(rows_left == 0,
           result,
           rec(rows_left - 1, [zeros(cols), ...result]))
)(rows, [])

zeros_2d(3, 4)       // [[0,0,0,0], [0,0,0,0], [0,0,0,0]]

// identity_matrix(n) - Create n×n identity matrix
let identity_matrix = n => (
    (row, result) =>
        if(row >= n,
           result,
           rec(row + 1, [
               ...result,
               fill_with(n, col => if(col == row, 1, 0))
           ]))
)(0, [])

identity_matrix(3)
// [[1, 0, 0], [0, 1, 0], [0, 0, 1]]

// ============================================================================
// 12. Practical: Moving Average Window
// ============================================================================

// take(n, arr) - Take first n elements
let take = (n, arr) => arr[..n-1]

// drop(n, arr) - Drop first n elements
let drop = (n, arr) => arr[n..]

// moving_avg_recursive(arr, window) - Calculate moving averages
let moving_avg_recursive = (arr, window) => (
    (remaining, result) =>
        if(remaining[window - 1] == remaining[-1],  // Last window
           [...result, mean(take(window, remaining))],
           rec(drop(1, remaining), [...result, mean(take(window, remaining))]))
)(arr, [])

// Would need proper implementation with length checks

// ============================================================================
// 13. GCD with Accumulator (Euclidean Algorithm)
// ============================================================================

let gcd = (a, b) => (
    (x, y) => if(y == 0, x, rec(y, x % y))
)(a, b)

gcd(48, 18)          // 6
gcd(100, 35)         // 5

// ============================================================================
// Summary: Key Patterns
// ============================================================================

// Pattern 1: Counter with accumulator
// (left, acc) => if(left == 0, acc, rec(left - 1, f(acc)))

// Pattern 2: Builder with accumulator
// (index, vector) => if(index >= n, vector, rec(index + 1, [...vector, value]))

// Pattern 3: Tail recursion simulation
// (current, acc) => if(base_case, acc, rec(next, update(acc)))

// Pattern 4: Range generation
// (current, vector) => if(current >= end, vector, rec(current + step, [...vector, current]))

// Pattern 5: Nested recursion
// Combine multiple IIFE patterns for multi-dimensional operations

// ============================================================================
// Why This Pattern is Powerful
// ============================================================================

// 1. ✅ Simulates tail-call optimization with accumulator
// 2. ✅ Keeps intermediate state in function parameters
// 3. ✅ Maintains immutability with spread operator
// 4. ⚠️ Still limited to ~50 iterations due to stack constraints
// 5. ✅ Self-contained: no external state needed
// 6. ✅ Composable: can nest IIFEs for complex operations

// ============================================================================
// IMPORTANT: Recursion Depth Limit
// ============================================================================

// ⚠️ Testing the limit:

range(5)     // ✅ Works: [0, 1, 2, 3, 4]
range(10)    // ✅ Works: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
range(40)    // ✅ Works (but getting close to limit)
// range(50)    // ❌ Stack overflow!

// Why only 50?
// Each recursive call involves:
// - Cloning the entire evaluation environment
// - Cloning the function for 'rec' binding
// - Creating progressively larger vectors with spread operator
// - Pushing/popping scopes
// This exhausts Rust's 2MB default stack size quickly

// ============================================================================
// Better Alternatives for Large Ranges
// ============================================================================

// ✅ Use built-in linspace instead:
let range_safe = n => linspace(0, n - 1, n)

range_safe(100)    // ✅ Works!
range_safe(1000)   // ✅ Works!
range_safe(10000)  // ✅ Works!

// ✅ Or use map with linspace:
let zeros_safe = n => map(_ => 0, linspace(0, n - 1, n))
let ones_safe = n => map(_ => 1, linspace(0, n - 1, n))

zeros_safe(100)    // ✅ Works perfectly
ones_safe(1000)    // ✅ No stack issues

// ============================================================================
// Summary
// ============================================================================

// IIFE + accumulator pattern is elegant and powerful for:
// ✅ Small iterations (n < 40)
// ✅ Learning recursion techniques
// ✅ Algorithms with naturally small depth (GCD, tree depth, etc.)

// For large iterations, use:
// ✅ Built-in functions (linspace, map, reduce, filter)
// ✅ Higher-order functions instead of explicit recursion

// See: docs/language/25-performance-limitations.md

// ============================================================================
