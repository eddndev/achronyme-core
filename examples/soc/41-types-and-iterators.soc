// =============================================================================
// Example 41: Type System and Iterators
// Demonstrates gradual typing, type aliases, and generator-based iterators
// =============================================================================

// -----------------------------------------------------------------------------
// Part 1: Type Aliases for Domain Modeling
// -----------------------------------------------------------------------------
print("=== Part 1: Type Aliases ===")

// Define semantic types for our domain
type Point2D = { x: Number, y: Number }
type Point3D = { x: Number, y: Number, z: Number }
type Distance = Number
type Temperature = Number
type Velocity = { dx: Number, dy: Number }

// Use type annotations with our aliases
let origin: Point2D = { x: 0, y: 0 }
let target: Point2D = { x: 3, y: 4 }

print("Origin point:")
print(origin)
print("Target point:")
print(target)

// Calculate distance with typed function
let distance: (Point2D, Point2D): Distance = (p1, p2) => do {
    let dx = p2.x - p1.x
    let dy = p2.y - p1.y
    sqrt(dx * dx + dy * dy)
}

let d: Distance = distance(origin, target)
print("Distance from origin to target: " + str(d))

// -----------------------------------------------------------------------------
// Part 2: Type Checking with Union Types
// -----------------------------------------------------------------------------
print("\n=== Part 2: Type Checking ===")

// Define flexible types
type MaybeNumber = Number | null
type StringOrNumber = String | Number

// Function that handles optional values
let safeDivide: (Number, Number): MaybeNumber = (a, b) =>
    if(b == 0) { null } else { a / b }

let result1: MaybeNumber = safeDivide(10, 2)
let result2: MaybeNumber = safeDivide(10, 0)

print("10 / 2 = " + str(result1))
print("10 / 0 = " + str(result2))

// Type checking with typeof()
let checkType = (value) => do {
    let t = typeof(value)
    print("Value " + str(value) + " has type: " + t)
}

checkType(42)
checkType("hello")
checkType(true)
checkType([1, 2, 3])
checkType({ name: "test", value: 100 })
checkType(null)

// -----------------------------------------------------------------------------
// Part 3: Simple Generators (Sequential Yields)
// -----------------------------------------------------------------------------
print("\n=== Part 3: Simple Generators ===")

// A simple generator that yields a sequence
let simpleSequence = () => generate {
    print("  Yielding 1...")
    yield 1
    print("  Yielding 2...")
    yield 2
    print("  Yielding 3...")
    yield 3
    print("  Generator done!")
}

let gen1 = simpleSequence()

print("First call to next():")
let r1 = gen1.next()
print("  Result: { value: " + str(r1.value) + ", done: " + str(r1.done) + " }")

print("Second call to next():")
let r2 = gen1.next()
print("  Result: { value: " + str(r2.value) + ", done: " + str(r2.done) + " }")

print("Third call to next():")
let r3 = gen1.next()
print("  Result: { value: " + str(r3.value) + ", done: " + str(r3.done) + " }")

print("Fourth call to next() (exhausted):")
let r4 = gen1.next()
print("  Result: { value: " + str(r4.value) + ", done: " + str(r4.done) + " }")

// -----------------------------------------------------------------------------
// Part 4: Generator with Return Value
// -----------------------------------------------------------------------------
print("\n=== Part 4: Generator with Return ===")

let boundedGenerator = () => generate {
    yield 10
    yield 20
    return 100
}

let gen2 = boundedGenerator()
print("Yielding from bounded generator:")
print("  First: " + str(gen2.next().value))
print("  Second: " + str(gen2.next().value))

let final = gen2.next()
print("  Final (return value): " + str(final.value) + ", done: " + str(final.done))

// -----------------------------------------------------------------------------
// Part 5: Generators Yielding Complex Values
// -----------------------------------------------------------------------------
print("\n=== Part 5: Generators with Complex Values ===")

// Generator yielding typed records
let pointGenerator = () => generate {
    yield { x: 0, y: 0 }
    yield { x: 1, y: 1 }
    yield { x: 2, y: 4 }
    yield { x: 3, y: 9 }
}

let pointGen = pointGenerator()
let p1 = pointGen.next().value
let p2 = pointGen.next().value
let p3 = pointGen.next().value

print("Generated points:")
print("  P1: (" + str(p1.x) + ", " + str(p1.y) + ")")
print("  P2: (" + str(p2.x) + ", " + str(p2.y) + ")")
print("  P3: (" + str(p3.x) + ", " + str(p3.y) + ")")

// Calculate area under curve using generated points
let area = (p2.x - p1.x) * (p1.y + p2.y) / 2 + (p3.x - p2.x) * (p2.y + p3.y) / 2
print("Approximate area: " + str(area))

// -----------------------------------------------------------------------------
// Part 6: For-In Loop with Manual Iterator
// -----------------------------------------------------------------------------
print("\n=== Part 6: For-In Loop with Manual Iterator ===")

// Create an iterator using a record with next() method
// This simulates a range iterator
mut iterState = { mut current: 0, max: 5 }
let rangeIterator = {
    next: () => do {
        if(iterState.current >= iterState.max) {
            { value: null, done: true }
        } else {
            let val = iterState.current
            iterState.current = iterState.current + 1
            { value: val, done: false }
        }
    }
}

print("Iterating over range [0, 5):")
mut sum = 0
for(x in rangeIterator) {
    print("  x = " + str(x))
    sum = sum + x
}
print("Sum: " + str(sum))

// -----------------------------------------------------------------------------
// Part 7: Combining Types and Iterators
// -----------------------------------------------------------------------------
print("\n=== Part 7: Typed Iterator Pattern ===")

// Type definitions for iterator protocol
type IteratorResult = { value: Number | null, done: Boolean }

// Create a typed iterator factory
let createCounter: (Number): { next: (): IteratorResult } = (limit) => do {
    mut count = 0
    {
        next: () => do {
            if(count >= limit) {
                { value: null, done: true }
            } else {
                count = count + 1
                { value: count, done: false }
            }
        }
    }
}

let counter = createCounter(3)
print("Typed counter iterator:")
print(counter.next())
print(counter.next())
print(counter.next())
print(counter.next())

// -----------------------------------------------------------------------------
// Part 8: Real-World Example - Temperature Readings
// -----------------------------------------------------------------------------
print("\n=== Part 8: Temperature Sensor Simulation ===")

type TemperatureReading = {
    timestamp: Number,
    celsius: Temperature,
    fahrenheit: Temperature
}

// Generator that yields temperature readings
let temperatureSensor = () => generate {
    // Simulate 3 readings
    yield { timestamp: 0, celsius: 20.0, fahrenheit: 68.0 }
    yield { timestamp: 1, celsius: 21.5, fahrenheit: 70.7 }
    yield { timestamp: 2, celsius: 19.8, fahrenheit: 67.64 }
}

let sensor = temperatureSensor()

print("Temperature readings:")
let reading1 = sensor.next().value
let reading2 = sensor.next().value
let reading3 = sensor.next().value

print("  t=" + str(reading1.timestamp) + ": " + str(reading1.celsius) + "C (" + str(reading1.fahrenheit) + "F)")
print("  t=" + str(reading2.timestamp) + ": " + str(reading2.celsius) + "C (" + str(reading2.fahrenheit) + "F)")
print("  t=" + str(reading3.timestamp) + ": " + str(reading3.celsius) + "C (" + str(reading3.fahrenheit) + "F)")

// Calculate average temperature
let avgCelsius = (reading1.celsius + reading2.celsius + reading3.celsius) / 3
print("Average temperature: " + str(avgCelsius) + "C")

// Type-safe temperature conversion
let celsiusToFahrenheit: (Temperature): Temperature = (c) => c * 9 / 5 + 32
print("Conversion check: " + str(avgCelsius) + "C = " + str(celsiusToFahrenheit(avgCelsius)) + "F")

// -----------------------------------------------------------------------------
// Summary
// -----------------------------------------------------------------------------
print("\n=== Summary ===")
print("This example demonstrated:")
print("1. Type aliases for semantic domain types")
print("2. Function type annotations with arrow syntax")
print("3. Union types (Number | null)")
print("4. typeof() for runtime type checking")
print("5. Simple generators with yield keyword")
print("6. Generator return values")
print("7. Generators yielding complex records")
print("8. For-in loops with manual iterators")
print("9. Combining types and iterators for type-safe iteration")
print("10. Real-world pattern: typed sensor data streams")

print("\nAchronyme: La robustez es opcional, la simplicidad es el default.")
