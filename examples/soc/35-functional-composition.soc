// ============================================================================
// Example 35: Advanced Functional Composition with IIFE, Self & Slicing
// ============================================================================
// Demonstrates:
// - Complex functional compositions using IIFE
// - Combining objects, recursion, and tensor operations
// - Advanced patterns: currying, partial application, composition
// - Real-world scenarios: data processing pipelines
// ============================================================================

// Example 1: Currying with IIFE
// ------------------------------
// Currying: Transform f(a, b, c) into f(a)(b)(c)

let add = x => y => x + y
let add5 = add(5)
let result1 = add5(10)                    // 15

// Multiply with IIFE for immediate partial application
let multiply = x => y => x * y
let double = ((x => y => x * y)(2))
let result2 = double(7)                   // 14

// Complex curried function with IIFE
let curriedPower = base => exp => (
    helper => helper(base, exp)
)(
    (b, e) => if(e <= 0, 1, b * rec(b, e - 1))
)

let square = curriedPower(2)
let result3 = square(8)                   // 256 (2^8)


// Example 2: Function Composition
// --------------------------------
let compose = f => g => x => f(g(x))

// Using IIFE to create composed functions
let addThen = x => (
    adder => doubler => (compose(doubler))(adder)
)(
    n => n + x
)(
    n => n * 2
)

let add3ThenDouble = addThen(3)
let result4 = add3ThenDouble(5)           // (5 + 3) * 2 = 16


// Example 3: Data Processing Pipeline with Objects and Slicing
// -------------------------------------------------------------
let dataProcessor = {
    // Raw data
    data: [5, 12, 8, 19, 3, 15, 7, 22, 11, 6],

    // Filter using higher-order function
    filterGreaterThan: threshold => filter(
        x => x > threshold,
        self.data
    ),

    // Map with transformation
    transform: fn => map(fn, self.data),

    // Reduce using built-in
    reduce: fn => initial => reduce(fn, initial, self.data),

    // Pipeline: filter, transform, reduce
    pipeline: () => (
        filtered => (
            transformed => (
                sum => sum
            )(
                (self.reduce(
                    (acc, x) => acc + x
                ))(0)
            )
        )(
            map(x => x * x, filtered)
        )
    )(self.filterGreaterThan(10)),

    // Get statistical slice
    getTopHalf: () => (
        sorted => sorted[5..]
    )(
        // Conceptual sort - using raw data slice
        self.data[5..]
    )
}

let filtered = dataProcessor.filterGreaterThan(10)     // [12, 19, 15, 22, 11]
let transformed = dataProcessor.transform(x => x * 2)  // All doubled
let pipelineResult = dataProcessor.pipeline()          // Sum of squares of filtered


// Example 4: Matrix Operations with IIFE
// ---------------------------------------
let matrixOps = {
    // Create matrix using map
    create: (rows, cols, fillValue) => map(
        r => map(c => fillValue, [0, 1, 2]),
        [0, 1, 2]
    ),

    // Matrix multiplication helper (conceptual)
    multiplyRow: (row, col) => (
        helper => helper(0, 0)
    )(
        (idx, acc) => if(
            idx >= 3,
            acc,
            rec(idx + 1, acc + row[idx] * col[idx])
        )
    )
}

let matrix3x3 = matrixOps.create(3, 3, 1)


// Example 5: Advanced Slicing with Functional Patterns
// -----------------------------------------------------
let timeSeries = {
    data: [
        [100, 102, 98,  101],  // Hour 0
        [105, 107, 103, 106],  // Hour 1
        [95,  97,  93,  96],   // Hour 2
        [110, 112, 108, 111],  // Hour 3
        [102, 104, 100, 103],  // Hour 4
        [98,  100, 96,  99]    // Hour 5
    ],

    // Get specific time window
    getWindow: (startHour, endHour) => self.data[startHour..endHour],

    // Analyze specific sensor across time window
    analyzeSensor: sensorId => (
        readings => (
            avg => avg
        )(
            sum(readings) / 6
        )
    )(self.data[.., sensorId]),

    // Get peak hours using IIFE
    findPeaks: () => (
        hourAverages => (
            maxIdx => maxIdx
        )(
            // Conceptual argmax
            2  // Example: hour 2 had peaks
        )
    )(
        map(
            row => sum(row) / 4,
            self.data
        )
    ),

    // Sliding window analysis (conceptual with fixed windows)
    slidingWindow: windowSize => map(
        i => self.data[i..(i + windowSize)],
        [0, 1, 2, 3]
    )
}

let morningData = timeSeries.getWindow(0, 3)       // First 3 hours
let sensor0Avg = timeSeries.analyzeSensor(0)       // Avg of sensor 0
let windows = timeSeries.slidingWindow(3)          // 3-hour windows


// Example 6: Recursive Object with Slicing
// -----------------------------------------
let recursiveAnalyzer = {
    data: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],

    // Recursive sum with slicing
    sumRange: (start, end) => (
        slice => (helper => helper(slice, 0, 0))(
            (arr, idx, acc) => if(
                idx >= end - start,
                acc,
                rec(arr, idx + 1, acc + arr[idx])
            )
        )
    )(self.data[start..end]),

    // Partition using filter
    partition: predicate => {
        truthy: filter(predicate, self.data),
        falsy: filter(x => predicate(x) == false, self.data)
    },

    // Find subsequence matching condition (simplified)
    findSubsequence: (length, condition) => filter(
        i => condition(self.data[i..(i + length)]),
        [0, 1, 2, 3, 4, 5]
    )
}

let sum3to7 = recursiveAnalyzer.sumRange(3, 7)     // Sum of [4,5,6,7]
let partitioned = recursiveAnalyzer.partition(x => x > 5)  // Split at 5


// Example 7: IIFE Factory with Closure
// -------------------------------------
let createCounter = initialValue => (
    // IIFE that creates object with closure over initialValue
    start => {
        current: start,

        // Increment using self
        increment: () => {
            current: self.current + 1,
            increment: self.increment,
            decrement: self.decrement,
            value: self.value
        },

        // Decrement using self
        decrement: () => {
            current: self.current - 1,
            increment: self.increment,
            decrement: self.decrement,
            value: self.value
        },

        // Get current value
        value: () => self.current
    }
)(initialValue)

let counter = createCounter(10)
let val1 = counter.value()                 // 10
let counter2 = counter.increment()
let val2 = counter2.value()                // 11


// Example 8: Combining Everything - Data Science Pipeline
// --------------------------------------------------------
let dataScience = {
    rawData: [
        [12, 15, 18, 14, 16],
        [22, 25, 28, 24, 26],
        [32, 35, 38, 34, 36],
        [42, 45, 48, 44, 46]
    ],

    // Normalize a row using IIFE
    normalizeRow: row => (
        mean => (
            stdDev => (
                normalizer => normalizer(row, 0, [])
            )(
                (arr, idx, acc) => if(
                    idx >= 5,
                    acc,
                    rec(arr, idx + 1, [acc, (arr[idx] - mean) / stdDev])
                )
            )
        )(
            sqrt(
                sum(map(x => (x - mean) * (x - mean), row)) / 5
            )
        )
    )(sum(row) / 5),

    // Process entire dataset using map
    processAll: () => map(
        row => self.normalizeRow(row),
        self.rawData
    ),

    // Extract and analyze specific time column
    analyzeTime: timeIdx => (
        column => {
            values: column,
            mean: sum(column) / 4,
            min: column[0],  // Conceptual
            max: column[3]   // Conceptual
        }
    )(self.rawData[.., timeIdx])
}

let row0Normalized = dataScience.normalizeRow(dataScience.rawData[0])
let time2Analysis = dataScience.analyzeTime(2)


// Summary Output
// --------------
result1              // 15
result4              // 16
filtered             // Data > 10
sum3to7              // Sum of [4,5,6,7]
val1                 // 10
val2                 // 11
time2Analysis        // Statistics for time column 2
