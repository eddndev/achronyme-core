// ============================================================================
// return Statement Examples
// ============================================================================
// Demonstrates the new return statement for early function exit
// ============================================================================

print("=== return Statement Examples ===")
print("")

// ============================================================================
// 1. Basic Early Return
// ============================================================================

print("1. Basic Early Return")
print("-" * 40)

let validatePositive = (x) => do {
    if (x <= 0) {
        return false
    };
    true
}

print("validatePositive(-5) =", validatePositive(-5))
print("validatePositive(0) =", validatePositive(0))
print("validatePositive(10) =", validatePositive(10))
print("")

// ============================================================================
// 2. Guard Clauses Pattern
// ============================================================================

print("2. Guard Clauses (reduce nesting)")
print("-" * 40)

// Without return - deeply nested
let processNested = (data) => do {
    if (len(data) > 0) {
        if (sum(data) > 0) {
            mean(data)
        } else {
            0
        }
    } else {
        0
    }
}

// With return - guard clauses (cleaner)
let processGuarded = (data) => do {
    if (len(data) == 0) {
        return 0
    };
    if (sum(data) <= 0) {
        return 0
    };
    mean(data)
}

let testData1 = [10, 20, 30]
let testData2 = []
let testData3 = [-5, -10]

print("With data [10, 20, 30]:")
print("  Nested:", processNested(testData1))
print("  Guarded:", processGuarded(testData1))
print("With empty array:")
print("  Nested:", processNested(testData2))
print("  Guarded:", processGuarded(testData2))
print("With negative data [-5, -10]:")
print("  Nested:", processNested(testData3))
print("  Guarded:", processGuarded(testData3))
print("")

// ============================================================================
// 3. Multiple Return Points
// ============================================================================

print("3. Multiple Return Points")
print("-" * 40)

let categorize = (x) => do {
    if (x < 0) {
        return "negative"
    };
    if (x == 0) {
        return "zero"
    };
    if (x < 10) {
        return "small positive"
    };
    if (x < 100) {
        return "medium positive"
    };
    "large positive"
}

print("categorize(-5) =", categorize(-5))
print("categorize(0) =", categorize(0))
print("categorize(5) =", categorize(5))
print("categorize(50) =", categorize(50))
print("categorize(200) =", categorize(200))
print("")

// ============================================================================
// 4. Validation with Multiple Checks
// ============================================================================

print("4. Complex Validation")
print("-" * 40)

let validateScore = (score) => do {
    if (score < 0) {
        print("  Error: Score cannot be negative");
        return false
    };

    if (score > 100) {
        print("  Error: Score cannot exceed 100");
        return false
    };

    print("  Valid score");
    true
}

print("validateScore(-10):")
validateScore(-10)
print("")

print("validateScore(150):")
validateScore(150)
print("")

print("validateScore(85):")
validateScore(85)
print("")

// ============================================================================
// 5. Return in Recursive Functions
// ============================================================================

print("5. Return in Recursive Functions")
print("-" * 40)

// Find first element matching predicate
let findIndex = (arr, predicate, index) => do {
    if (index >= len(arr)) {
        return -1
    };
    if (predicate(arr[index])) {
        return index
    };
    rec(arr, predicate, index + 1)
}

let find = (arr, predicate) => findIndex(arr, predicate, 0)

let numbers = [1, 3, 5, 8, 10, 12]
let isEven = (x) => x % 2 == 0
let isGreaterThan10 = (x) => x > 10

print("Array:", numbers)
print("Find first even:", find(numbers, isEven))
print("Find first > 10:", find(numbers, isGreaterThan10))
print("Find first > 100:", find(numbers, (x) => x > 100))
print("")

// Binary search with early return
let binarySearch = (arr, target, left, right) => do {
    if (left > right) {
        return -1
    };

    let mid = floor((left + right) / 2);

    if (arr[mid] == target) {
        return mid
    };

    if (arr[mid] > target) {
        return rec(arr, target, left, mid - 1)
    };

    rec(arr, target, mid + 1, right)
}

let search = (arr, target) => binarySearch(arr, target, 0, len(arr) - 1)

let sorted = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
print("Sorted array:", sorted)
print("Binary search for 7:", search(sorted, 7))
print("Binary search for 13:", search(sorted, 13))
print("Binary search for 20:", search(sorted, 20))
print("")

// ============================================================================
// 6. Return vs Last Expression
// ============================================================================

print("6. Return vs Last Expression")
print("-" * 40)

// Without return - last expression is returned
let method1 = (x) => do {
    let doubled = x * 2;
    let added = doubled + 10;
    added
}

// With explicit return - same behavior
let method2 = (x) => do {
    let doubled = x * 2;
    let added = doubled + 10;
    return added
}

// With early return - different behavior
let method3 = (x) => do {
    if (x < 0) {
        return 0
    };
    let doubled = x * 2;
    let added = doubled + 10;
    added
}

print("method1(5) =", method1(5))
print("method2(5) =", method2(5))
print("method3(5) =", method3(5))
print("method3(-5) =", method3(-5), "(early return)")
print("")

// ============================================================================
// 7. Return in if-else Blocks
// ============================================================================

print("7. Return in if-else Blocks")
print("-" * 40)

// Return in both branches
let sign = (x) => if (x < 0) {
    return -1
} else if (x > 0) {
    return 1
} else {
    return 0
}

print("sign(-10) =", sign(-10))
print("sign(0) =", sign(0))
print("sign(10) =", sign(10))
print("")

// Return only in if (no else needed)
let checkRange = (x, min, max) => do {
    if (x < min) {
        print("  Value too small");
        return false
    };
    if (x > max) {
        print("  Value too large");
        return false
    };
    print("  Value in range");
    true
}

print("checkRange(5, 0, 10):")
checkRange(5, 0, 10)
print("")

print("checkRange(-5, 0, 10):")
checkRange(-5, 0, 10)
print("")

print("checkRange(15, 0, 10):")
checkRange(15, 0, 10)
print("")

// ============================================================================
// 8. Nested Returns
// ============================================================================

print("8. Nested Returns")
print("-" * 40)

let processValue = (x, y) => do {
    print("  Checking x...");
    if (x < 0) {
        print("  x is negative, returning early");
        return "x negative"
    };

    print("  x is valid, checking y...");
    if (y < 0) {
        print("  y is negative, returning early");
        return "y negative"
    };

    print("  Both valid, computing result");
    "both positive"
}

print("processValue(-5, 10):")
print(" ", processValue(-5, 10))
print("")

print("processValue(5, -10):")
print(" ", processValue(5, -10))
print("")

print("processValue(5, 10):")
print(" ", processValue(5, 10))
print("")

// ============================================================================
// 9. Array Processing with Early Exit
// ============================================================================

print("9. Array Processing with Early Exit")
print("-" * 40)

let validateArray = (arr) => do {
    let check = (index) => do {
        if (index >= len(arr)) {
            return true
        };

        let value = arr[index];

        if (value < 0) {
            print("  Error: negative value at index", index);
            return false
        };

        if (value > 100) {
            print("  Error: value too large at index", index);
            return false
        };

        rec(index + 1)
    };

    check(0)
}

print("validateArray([10, 20, 30]):")
print(" ", validateArray([10, 20, 30]))
print("")

print("validateArray([10, -5, 30]):")
print(" ", validateArray([10, -5, 30]))
print("")

print("validateArray([10, 150, 30]):")
print(" ", validateArray([10, 150, 30]))
print("")

// ============================================================================
// 10. Return with Complex Logic
// ============================================================================

print("10. Return with Complex Logic")
print("-" * 40)

// Grading system with early returns
let calculateGrade = (score, attendance) => do {
    // Validation
    if (score < 0 || score > 100) {
        print("  Invalid score");
        return "ERROR"
    };

    if (attendance < 0 || attendance > 100) {
        print("  Invalid attendance");
        return "ERROR"
    };

    // Automatic fail for low attendance
    if (attendance < 75) {
        print("  Failed due to attendance:", attendance, "%");
        return "F"
    };

    // Grade based on score
    if (score >= 90) {
        return "A"
    };
    if (score >= 80) {
        return "B"
    };
    if (score >= 70) {
        return "C"
    };
    if (score >= 60) {
        return "D"
    };
    "F"
}

print("calculateGrade(95, 90):")
print(" ", calculateGrade(95, 90))
print("")

print("calculateGrade(85, 70):")
print(" ", calculateGrade(85, 70))
print("")

print("calculateGrade(95, 150):")
print(" ", calculateGrade(95, 150))
print("")

// ============================================================================
// Summary
// ============================================================================

print("=" * 60)
print("Summary")
print("=" * 60)
print("")
print("✓ return statement allows early function exit")
print("✓ Stops execution immediately - code after return is skipped")
print("✓ Can be used in if-else blocks, do blocks, recursive functions")
print("✓ Perfect for guard clauses and validation")
print("✓ Reduces nesting and improves code readability")
print("✓ Multiple return points are allowed in a function")
print("")
print("Best practices:")
print("• Use return for guard clauses (early validation)")
print("• Use return to avoid deep nesting")
print("• Use return in recursive search/find functions")
print("• Prefer last expression when no early exit needed")
