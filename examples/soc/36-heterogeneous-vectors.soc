// ============================================================================
// Example 36: Heterogeneous Vectors (Mixed-Type Collections)
// ============================================================================
// Demonstrates Achronyme's support for vectors containing mixed types,
// enabling flexible data structures like tuples, records, and function
// collections all in the same array.
// ============================================================================

// ============================================================================
// 1. Basic Mixed-Type Vectors
// ============================================================================

// Simple mixed types
let mixed1 = [1, "hello", true]
mixed1

// Access by index
mixed1[0]    // 1
mixed1[1]    // "hello"
mixed1[2]    // true

// More complex mix
let mixed2 = [
    42,                 // Number
    "Alice",            // String
    {x: 10, y: 20},    // Record
    x => x^2,          // Function
    [1, 2, 3],         // Tensor
    true               // Boolean
]
mixed2

// ============================================================================
// 2. Tuple-Like Structures
// ============================================================================

// User record as tuple (ID, Name, Email, Age, Active)
let user = [1, "Bob Smith", "bob@example.com", 35, true]

user[0]    // ID: 1
user[1]    // Name: "Bob Smith"
user[4]    // Active: true

// Function that returns multiple values (tuple)
let divmod = (a, b) => [a / b, a % b]
let result = divmod(17, 5)
result[0]  // Quotient: 3.4
result[1]  // Remainder: 2

// ============================================================================
// 3. Data Table (Rows and Columns)
// ============================================================================

// Table with mixed-type columns
let products = [
    [1, "Laptop", 999.99, true, "Electronics"],
    [2, "Mouse", 29.99, true, "Accessories"],
    [3, "Monitor", 399.99, false, "Electronics"],
    [4, "Keyboard", 79.99, true, "Accessories"]
]

// Access: products[row][column]
products[0][1]    // "Laptop"
products[1][2]    // 29.99
products[2][3]    // false (not in stock)

// Extract column (all product names)
map(row => row[1], products)
// ["Laptop", "Mouse", "Monitor", "Keyboard"]

// Filter in-stock products
filter(row => row[3], products)

// ============================================================================
// 4. Function Collections and Pipelines
// ============================================================================

// Collection of transformation functions
let transforms = [
    x => x * 2,              // Double
    x => x + 10,             // Add 10
    x => x^2,                // Square
    x => if(x < 0, -x, x)    // Absolute value
]

// Apply different transforms
transforms[0](5)   // 10
transforms[1](5)   // 15
transforms[2](5)   // 25
transforms[3](-5)  // 5

// Apply all transforms in sequence
let apply_pipeline = (funcs, value) =>
    reduce((acc, f) => f(acc), value, funcs)

apply_pipeline(transforms, 3)  // abs((((3*2)+10)^2))

// ============================================================================
// 5. Configuration Objects as Arrays
// ============================================================================

// Configuration: [Environment, Port, SSL, Options, Logger]
let config = [
    "production",
    8080,
    true,
    {timeout: 30000, retries: 3},
    x => x  // Logger function placeholder
]

config[0]           // "production"
config[1]           // 8080
config[3].timeout   // 30000

// ============================================================================
// 6. State Machine with Mixed Data
// ============================================================================

// State: [StateName, Count, LastUpdate, Handler]
let state = [
    "running",
    42,
    "2024-01-15",
    x => x + 1
]

state[0]           // Current state: "running"
state[1]           // Count: 42
state[3](10)       // Apply handler: 11

// ============================================================================
// 7. Nested Heterogeneous Structures
// ============================================================================

let complex_data = [
    [1, 2, 3],                          // Tensor
    "metadata",                         // String
    {
        name: "Dataset A",
        size: 1000,
        transform: x => x * 2
    },                                  // Record with function
    [
        x => x + 1,
        x => x^2,
        x => x / 2
    ],                                  // Vector of functions
    [
        [1, "Alice", true],
        [2, "Bob", false]
    ],                                  // Table (nested mixed arrays)
    true                                // Flag
]

// Navigate nested structure
complex_data[0][1]              // 2 (from tensor)
complex_data[2].name            // "Dataset A"
complex_data[2].transform(5)    // 10
complex_data[3][1](5)           // 25 (square function)
complex_data[4][0][1]           // "Alice"

// ============================================================================
// 8. Mixed Type Processing with Higher-Order Functions
// ============================================================================

// Extract specific types from mixed array
let data = [1, "hello", 2, "world", 3, true, 4]

// Note: We can't directly type-check in current implementation,
// but we can use the structure

// Access numeric elements (assuming known positions)
let numbers = [data[0], data[2], data[4], data[6]]
numbers  // [1, 2, 3, 4]

// ============================================================================
// 9. Return Values with Status
// ============================================================================

// Function returning [success, result/error, metadata]
let safe_divide = (a, b) => if(
    b == 0,
    [false, "Division by zero", {a: a, b: b}],
    [true, a / b, {a: a, b: b}]
)

let result1 = safe_divide(10, 2)
result1[0]  // true (success)
result1[1]  // 5 (result)

let result2 = safe_divide(10, 0)
result2[0]  // false (failure)
result2[1]  // "Division by zero"

// ============================================================================
// 10. Practical Use Case: CSV-Like Data Processing
// ============================================================================

// Simulated CSV row: [ID, Name, Department, Salary, Active]
let employees = [
    [1, "Alice Johnson", "Engineering", 95000, true],
    [2, "Bob Williams", "Marketing", 75000, true],
    [3, "Carol Davis", "Engineering", 105000, false],
    [4, "David Miller", "Sales", 85000, true]
]

// Calculate average salary of active employees
let active_employees = filter(emp => emp[4], employees)
let salaries = map(emp => emp[3], active_employees)
let avg_salary = sum(salaries) / 3

avg_salary  // Average of active employees

// Get all engineering staff
let engineering = filter(emp => emp[2] == "Engineering", employees)
engineering

// ============================================================================
// Summary
// ============================================================================
// Heterogeneous vectors enable:
// - Tuple-like structures (fixed-size, mixed-type)
// - Data tables (rows with different column types)
// - Function collections and pipelines
// - Flexible return values
// - Complex nested data structures
// - CSV/database-like data processing
// ============================================================================
