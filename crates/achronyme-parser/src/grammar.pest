// ============================================================================
// Achronyme SOC Language Grammar (Pest PEG)
// ============================================================================
// This grammar defines the complete syntax for the SOC (Second-Order Calculus)
// language used by Achronyme for mathematical computations.
//
// Features:
// - Arithmetic expressions with proper precedence
// - Boolean literals and logical operators (&&, ||, !)
// - Comparison operators (>, <, >=, <=, ==, !=)
// - Conditional expressions (if function)
// - Function calls (sin, cos, map, etc.)
// - Vectors and matrices
// - Lambda functions with closures
// - Variable declarations (let)
// - Higher-order functions
// - Complex numbers (3i, 2+3i)
// - String literals with escape sequences
// - Records (key-value pairs)
// - Edges and networks (A -> B, A -- B)
// ============================================================================

// ============================================================================
// Whitespace and Comments
// ============================================================================

// WHITESPACE excludes newlines - they are handled separately for statement separation
WHITESPACE = _{ " " | "\t" | "\r" }

// Newline: used for automatic statement separation
NEWLINE = _{ "\n" }

COMMENT = _{ "//" ~ (!"\n" ~ ANY)* }

// ============================================================================
// Literals
// ============================================================================

// Boolean literals: true, false
boolean = { "true" | "false" }

// Numbers: 123, 3.14, -42, 1.5e-10, 2.5E+3
// Use negative lookahead to prevent matching "5." when followed by another "." (for ranges like "5..")
number = @{
    "-"? ~ ASCII_DIGIT+ ~ ("." ~ !"." ~ ASCII_DIGIT+)? ~ (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}

// Complex numbers: 3i, -2i
// Note: Full complex (2+3i) is handled as arithmetic expression
complex = @{ number ~ "i" }

// String literals: "hello", "world"
// Supports escape sequences: \n, \t, \r, \\, \"
string_literal = @{
    "\"" ~ string_char* ~ "\""
}

string_char = {
    !("\"" | "\\") ~ ANY
  | "\\" ~ ("\"" | "\\" | "n" | "t" | "r")
}

// Reserved keywords (use word boundaries to prevent matching prefixes)
keyword = _{
    ("let" | "mut" | "rec" | "self" | "true" | "false" | "import" | "from" | "export" | "as" | "return" | "while" | "type" | "yield" | "generate" | "for" | "in") ~ !ASCII_ALPHANUMERIC
}

// Identifiers: x, foo, my_var, PI, sin (but not keywords)
identifier = @{
    !keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")*
}

// Field identifier: like identifier but allows keywords (for field access like e.from)
field_identifier = @{
    (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")*
}

// ============================================================================
// Composite Literals
// ============================================================================

// Spread expression: ...expr
spread_expr = {
    "..." ~ expr
}

// Array (N-dimensional tensor): [1, 2, 3], [[1, 2], [3, 4]], [[[1,2],[3,4]], [[5,6],[7,8]]], []
// This is now recursive to support arbitrary tensor dimensions
// Allow empty arrays with optional expression list
// Arrays can now contain spread expressions: [1, ...vec, 2]
// Allow optional newlines after [ and before ], and around commas
array_element = { spread_expr | expr }

array = {
    "[" ~ NEWLINE* ~ (array_element ~ (NEWLINE* ~ "," ~ NEWLINE* ~ array_element)*)? ~ NEWLINE* ~ "]"
}

// Vector and Matrix are now aliases for the unified array syntax
vector = { array }
matrix = { array }

// Record: { name: "Alice", age: 30, city: "Madrid" }
// Records can now contain spread expressions: { a: 1, ...other, b: 2 }
// Allow optional newlines after { and before }, and around commas
record_field_or_spread = { spread_expr | record_field }

record = {
    "{" ~ NEWLINE* ~ (record_field_or_spread ~ (NEWLINE* ~ "," ~ NEWLINE* ~ record_field_or_spread)*)? ~ NEWLINE* ~ "}"
}

// Mutable field keyword
mut_keyword = @{ "mut" ~ !ASCII_ALPHANUMERIC }

record_field = {
    (mut_keyword ~ identifier ~ ":" ~ expr)  // Mutable field: mut valor: 10
  | (identifier ~ ":" ~ expr)                // Immutable field: valor: 10
}

// ============================================================================
// Type Annotations (Gradual Typing System)
// ============================================================================

// Type annotation: union types or simple types
type_annotation = {
    union_type | simple_type_annotation
}

// Union types (core feature): Number | String | null
union_type = {
    simple_type_annotation ~ ("|" ~ simple_type_annotation)+
}

simple_type_annotation = {
    simple_type
  | tensor_type
  | vector_type
  | record_type
  | function_type
  | grouped_type
  | any_type
  | null_type
  | type_reference  // Reference to a type alias (must be last to avoid matching keywords)
}

// Type reference: identifier for type aliases (e.g., Point, Result, ApiResponse)
type_reference = {
    identifier
}

// Grouped type for precedence: ((Number) => String)
grouped_type = {
    "(" ~ type_annotation ~ ")" ~ !"=>"
}

// Simple types: Number, Boolean, String, Complex, Edge, Generator
simple_type = @{
    ("Number" | "Boolean" | "String" | "Complex" | "Generator" | "Edge") ~ !ASCII_ALPHANUMERIC
}

// Tensor type: Tensor<Number> or Tensor<Complex, [2,3]>
tensor_type = {
    "Tensor" ~ "<" ~ type_annotation ~ ("," ~ shape_spec)? ~ ">"
}

// Shape specification: [2, 3] or [_, _] for dynamic dimensions
shape_spec = {
    "[" ~ (dimension ~ ("," ~ dimension)*)? ~ "]"
}

// Dimension: number or _ for unknown dimension
dimension = { number | "_" }

// Vector type
vector_type = @{ "Vector" ~ !ASCII_ALPHANUMERIC }

// Record type: {field1: Type1, mut field2: Type2}
// Direct structural syntax (NO Record<...> wrapper)
record_type = {
    "{" ~ NEWLINE* ~
    (record_type_field ~ (NEWLINE* ~ "," ~ NEWLINE* ~ record_type_field)*)? ~
    NEWLINE* ~ "}"
}

record_type_field = {
    (mut_keyword ~ identifier ~ ":" ~ type_annotation)  // mut value: Number
  | (identifier ~ ":" ~ type_annotation)                // name: String
}

// Function type: (param types) => return type
// Examples: (Number) => String, (Number, String) => Boolean, () => Number
function_type = {
    "(" ~ (type_annotation ~ ("," ~ type_annotation)*)? ~ ")" ~ "=>" ~ type_annotation
}

// Any type (opt-out of type checking)
any_type = @{ "Any" ~ !ASCII_ALPHANUMERIC }

// Null type (for optional values)
null_type = @{ "null" ~ !ASCII_ALPHANUMERIC }

// ============================================================================
// Lambda Functions and Do Blocks (with Type Annotations)
// ============================================================================

// Typed parameter: x (untyped) OR x: Type (typed) - gradual typing
typed_param = {
    identifier ~ (":" ~ type_annotation)?
}

// Lambda parameters: single or multiple, with optional types
typed_lambda_params = {
    typed_param                                          // Single: x or x: Type
  | ("(" ~ (typed_param ~ ("," ~ typed_param)*)? ~ ")") // Multi/no params: (x: Number, y) or ()
}

// Legacy lambda parameters (kept for backward compatibility during migration)
lambda_params = {
    identifier                                       // Single param: x
  | ("(" ~ (identifier ~ ("," ~ identifier)*)? ~ ")") // Multi param or no params: (x, y) or ()
}

// ============================================================================
// Unified Block System
// ============================================================================
// Blocks can contain a sequence of statements or a single expression
// Used by: do blocks, if expressions, match expressions (future), etc.

// Generic block: { sequence or statement }
// The last value in the block is its return value
// statement includes expr, so this covers all cases
// Newlines after { and before } are optional and ignored
block = {
    "{" ~ NEWLINE* ~ (sequence | statement) ~ NEWLINE* ~ "}"
}

// Do block: do { ... }
// Explicit block expression with "do" keyword
do_block = {
    "do" ~ block
}

// Generate block: generate { ... }
// Creates a generator function body with yield support
generate_block = {
    "generate" ~ block
}

// Lambda body: can be an expression, do block, or generate block
lambda_body = {
    generate_block | do_block | expr
}

// Lambda with type annotations (gradual typing)
// Syntax: (x: Number, y) => x + y              (partial typing)
// Syntax: (x: Number, y: Number): Number => x + y  (full typing)
// Syntax: x => x^2                             (no typing - backward compatible)
// Syntax: x =>\n    expr                       (multi-line support)
lambda = {
    typed_lambda_params ~ (":" ~ type_annotation)? ~ "=>" ~ NEWLINE* ~ lambda_body
}

// ============================================================================
// Control Flow Expressions
// ============================================================================
// Extensible system for control flow: if, match (future), while (future), etc.

// Control flow expression: if, while, for-in, and more in the future
control_flow_expr = {
    if_expr
  | while_expr
  | for_in_loop
    // Future: | match_expr
}

// If expression: if(condition) { block } else { block }
// The condition MUST be in parentheses to avoid ambiguity with function calls
// Positive lookahead &"{" ensures we don't confuse with if(cond, then, else) function
if_expr = {
    "if" ~ "(" ~ expr ~ ")" ~ &"{" ~ block ~
    ("else" ~ (if_expr | block))?
}

// While loop: while(condition) { block }
while_expr = {
    "while" ~ "(" ~ expr ~ ")" ~ &"{" ~ block
}

// For-in loop: for(variable in iterable) { block }
// Iterates over an iterator (object with next() method)
for_in_loop = {
    "for" ~ "(" ~ identifier ~ "in" ~ expr ~ ")" ~ &"{" ~ block
}

// ============================================================================
// Function Calls
// ============================================================================

// ============================================================================
// Expressions (with operator precedence)
// ============================================================================

// Self-reference (for use in records) - use word boundary
self_ref = { "self" ~ !ASCII_ALPHANUMERIC }

// Rec-reference (for recursive function calls) - use word boundary
rec_ref = { "rec" ~ !ASCII_ALPHANUMERIC }

// Null literal (for optional types) - use word boundary
null_literal = { "null" ~ !ASCII_ALPHANUMERIC }

// Primary expressions (highest precedence)
// IMPORTANT: Order matters in PEG! More specific rules must come before general ones
primary = {
    boolean            // Boolean literals
  | string_literal     // String literals
  | null_literal       // Null literal (must come before identifier)
  | complex            // Must come before number (3i contains number)
  | number
  | control_flow_expr  // Control flow (if, match, etc.) - before record to avoid ambiguity
  | record             // Record literals { key: value }
  | array              // Arrays/tensors (vectors, matrices, and higher-dimensional)
  | do_block           // Do blocks (must come before lambda to avoid ambiguity)
  | lambda
  | self_ref           // Self-reference in records
  | rec_ref            // Rec-reference for recursive calls
  | identifier
  | "(" ~ expr ~ ")"
}

// Range expression for slicing: start..end, start.., ..end, ..
// We need to be explicit to avoid ambiguity with the greedy PEG parser
range_expr = {
    expr ~ ".." ~ expr  // start..end
  | expr ~ ".."          // start..
  | ".." ~ expr          // ..end
  | ".."                 // ..
}

// Access argument: can be an index expression or a range for slicing
// Try range_expr first since it's more specific
access_arg = {
    range_expr | expr
}

// Postfix Expressions: unified rule for member access, indexing, and function calls.
// This is the key fix that allows for arbitrary chaining of these operations,
// e.g., obj.field[index](args), by treating them as left-associative postfix operators.
postfix_expression = {
    primary ~ postfix_op*
}

postfix_op = {
    call_op | index_op | field_op
}

call_op = { "(" ~ (expr ~ ("," ~ expr)*)? ~ ")" }
index_op = { "[" ~ access_arg ~ ("," ~ access_arg)* ~ "]" }
field_op = { "." ~ field_identifier }

// Power (right-associative): 2^3^4 = 2^(3^4)
power = {
    postfix_expression ~ ("^" ~ power)?
}

// Unary operators: -x, !x
unary = {
    "-" ~ unary
  | "!" ~ unary
  | power
}

// Operators as separate rules (not silent, so they're captured)
mult_op = { "*" | "/" | "%" }
add_op = { "+" | "-" }
edge_op = { "->" | "<>" }
cmp_op = { "==" | "!=" | ">=" | "<=" | ">" | "<" }
logical_and_op = { "&&" }
logical_or_op = { "||" }

// Multiplicative: *, /, %
multiplicative = {
    unary ~ (mult_op ~ unary)*
}

// Additive: +, -
additive = {
    multiplicative ~ (add_op ~ multiplicative)*
}

// Edge: A -> B or A -- B with optional metadata
// Syntax: identifier edge_op identifier [":" expr]
edge = {
    additive ~ (edge_op ~ additive ~ (":" ~ additive)?)?
}

// Comparison: >, <, >=, <=, ==, !=
comparison = {
    edge ~ (cmp_op ~ edge)?
}

// Logical AND: &&
logical_and = {
    comparison ~ (logical_and_op ~ comparison)*
}

// Logical OR: ||
logical_or = {
    logical_and ~ (logical_or_op ~ logical_and)*
}

// Expression (entry point for expressions)
expr = { logical_or }

// ============================================================================
// Import/Export Statements
// ============================================================================

// Import item: can be a simple identifier or an aliased import
// Examples: foo, foo as bar
import_item = {
    identifier ~ ("as" ~ identifier)?
}

// Import list: { foo, bar, baz as qux }
import_list = {
    "{" ~ import_item ~ ("," ~ import_item)* ~ "}"
}

// Module path: a string literal representing the module path
// Examples: "math", "stats", "./my_module", "../utils/helpers"
module_path = { string_literal }

// Import statement: import { sin, cos } from "math"
// Also supports: import { mean as average } from "stats"
import_statement = {
    "import" ~ import_list ~ "from" ~ module_path
}

// Export statement: export { foo, bar }
// For future use when we support user-defined modules
export_statement = {
    "export" ~ import_list
}

// ============================================================================
// Statements (with Type Annotations)
// ============================================================================

// Let statement with optional type annotation
// Syntax: let x: Type = value  OR  let x = value
let_statement = {
    "let" ~ identifier ~ (":" ~ type_annotation)? ~ "=" ~ expr
}

// Mut statement with optional type annotation
// Syntax: mut x: Type = value  OR  mut x = value
mut_statement = {
    "mut" ~ identifier ~ (":" ~ type_annotation)? ~ "=" ~ expr
}

// Type alias statement
// Syntax: type Name = TypeAnnotation
// Examples:
//   type Point = { x: Number, y: Number }
//   type Result = Success | Error
//   type OptionalNumber = Number | null
type_alias_statement = {
    "type" ~ identifier ~ "=" ~ type_annotation
}

// Assignment: x = 20, obj.field = 30, arr[0] = 40
// Uses postfix_expression as target for maximum flexibility
// Semantic validation happens in evaluator
assignment = {
    postfix_expression ~ "=" ~ expr
}

// Return statement: return expr
// Returns from the current function with the given value
// Only valid inside lambda functions
// Note: "return" is protected by the keyword rule in identifier
return_statement = {
    "return" ~ expr
}

// Yield statement: yield expr
// Suspends generator execution and returns the value
// Only valid inside generate blocks
yield_statement = {
    "yield" ~ expr
}

// Statement: import, export, let, mut, type alias, return, yield, assignment, or expression
// Try import/export first, then return/yield, then assignment before expr to avoid ambiguity
statement = {
    import_statement
  | export_statement
  | let_statement
  | mut_statement
  | type_alias_statement
  | return_statement
  | yield_statement
  | assignment
  | expr
}

// Statement separator: semicolon (optionally followed by newlines) or one or more newlines
// This allows:
//   let a = 1; let b = 2   (semicolon only)
//   let a = 1;\n let b = 2 (semicolon + newline)
//   let a = 1\n let b = 2  (newline only)
statement_sep = _{ (";" ~ NEWLINE*) | NEWLINE+ }

// Optional trailing separator (for last statement in block)
statement_sep_opt = _{ ((";" ~ NEWLINE*) | NEWLINE+)? }

// Sequence: multiple statements separated by semicolons OR newlines
// Examples:
//   "let a = 1; let b = 2; a + b" (semicolons)
//   "let a = 1\nlet b = 2\na + b" (newlines)
//   "let a = 1; let b = 2\na + b" (mixed)
// The last statement doesn't need a separator
sequence = {
    statement ~ (statement_sep ~ statement)+ ~ statement_sep_opt
}

// Top-level expression: either a sequence or a single statement
top_level_expr = {
    sequence | statement
}

// ============================================================================
// Program (entry point)
// ============================================================================

// Program: sequence of top-level expressions (for REPL compatibility)
// Accept optional leading/trailing newlines for better REPL/file parsing
program = {
    SOI ~ NEWLINE* ~ top_level_expr* ~ NEWLINE* ~ EOI
}
