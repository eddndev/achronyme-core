// ============================================================================
// Achronyme SOC Language Grammar (Pest PEG)
// ============================================================================
// This grammar defines the complete syntax for the SOC (Second-Order Calculus)
// language used by Achronyme for mathematical computations.
//
// Features:
// - Arithmetic expressions with proper precedence
// - Boolean literals and logical operators (&&, ||, !)
// - Comparison operators (>, <, >=, <=, ==, !=)
// - Conditional expressions (if function)
// - Function calls (sin, cos, map, etc.)
// - Vectors and matrices
// - Lambda functions with closures
// - Variable declarations (let)
// - Higher-order functions
// - Complex numbers (3i, 2+3i)
// - String literals with escape sequences
// - Records (key-value pairs)
// - Edges and networks (A -> B, A -- B)
// ============================================================================

// ============================================================================
// Whitespace and Comments
// ============================================================================

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* }

// ============================================================================
// Literals
// ============================================================================

// Boolean literals: true, false
boolean = { "true" | "false" }

// Numbers: 123, 3.14, -42, 1.5e-10, 2.5E+3
// Use negative lookahead to prevent matching "5." when followed by another "." (for ranges like "5..")
number = @{
    "-"? ~ ASCII_DIGIT+ ~ ("." ~ !"." ~ ASCII_DIGIT+)? ~ (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}

// Complex numbers: 3i, -2i
// Note: Full complex (2+3i) is handled as arithmetic expression
complex = @{ number ~ "i" }

// String literals: "hello", "world"
// Supports escape sequences: \n, \t, \r, \\, \"
string_literal = @{
    "\"" ~ string_char* ~ "\""
}

string_char = {
    !("\"" | "\\") ~ ANY
  | "\\" ~ ("\"" | "\\" | "n" | "t" | "r")
}

// Reserved keywords
keyword = _{ "let" | "rec" | "self" | "true" | "false" }

// Identifiers: x, foo, my_var, PI, sin (but not keywords)
identifier = @{
    !keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")*
}

// ============================================================================
// Composite Literals
// ============================================================================

// Array (N-dimensional tensor): [1, 2, 3], [[1, 2], [3, 4]], [[[1,2],[3,4]], [[5,6],[7,8]]]
// This is now recursive to support arbitrary tensor dimensions
array = {
    "[" ~ expr ~ ("," ~ expr)* ~ "]"
}

// Vector and Matrix are now aliases for the unified array syntax
vector = { array }
matrix = { array }

// Record: { name: "Alice", age: 30, city: "Madrid" }
record = {
    "{" ~ (record_field ~ ("," ~ record_field)*)? ~ "}"
}

record_field = {
    identifier ~ ":" ~ expr
}

// ============================================================================
// Lambda Functions
// ============================================================================

// Lambda parameters: x or (x, y, z) or ()
lambda_params = {
    identifier                                       // Single param: x
  | ("(" ~ (identifier ~ ("," ~ identifier)*)? ~ ")") // Multi param or no params: (x, y) or ()
}

// Lambda: x => x^2 or (x, y) => x + y
lambda = {
    lambda_params ~ "=>" ~ expr
}

// ============================================================================
// Function Calls
// ============================================================================

// Callable path: identifier or field access path (sin, f.add, obj.nested.method)
// Also allows 'rec' and 'self' for function calls like rec(x) or self.method()
callable = @{
    (identifier | "rec" | "self") ~ ("." ~ identifier)*
}

// Function call: sin(x), map(f, v), f.add(1), obj.method(x, y)
// Also supports IIFE: (n => n * 2)(5), (() => 42)()
function_call = {
    (callable | ("(" ~ expr ~ ")")) ~ "(" ~ (expr ~ ("," ~ expr)*)? ~ ")"
}

// ============================================================================
// Expressions (with operator precedence)
// ============================================================================

// Self-reference (for use in records)
self_ref = { "self" }

// Rec-reference (for recursive function calls)
rec_ref = { "rec" }

// Primary expressions (highest precedence)
primary = {
    boolean        // Boolean literals
  | string_literal // String literals
  | complex        // Must come before number (3i contains number)
  | number
  | record         // Record literals { key: value }
  | array          // Arrays/tensors (vectors, matrices, and higher-dimensional)
  | lambda
  | function_call
  | self_ref       // Self-reference in records
  | rec_ref        // Rec-reference for recursive calls
  | identifier
  | "(" ~ expr ~ ")"
}

// Range expression for slicing: start..end, start.., ..end, ..
// We need to be explicit to avoid ambiguity with the greedy PEG parser
range_expr = {
    expr ~ ".." ~ expr  // start..end
  | expr ~ ".."          // start..
  | ".." ~ expr          // ..end
  | ".."                 // ..
}

// Access argument: can be an index expression or a range for slicing
// Try range_expr first since it's more specific
access_arg = {
    range_expr | expr
}

// Index/slice access: tensor[0, 1, 2], tensor[0, .., ..], tensor[0][1]
access = {
    primary ~ ("[" ~ access_arg ~ ("," ~ access_arg)* ~ "]")*
}

// Field access: record.field, record.nested.field
// Updated to use 'access' as base to support combined indexing and field access
field_access = {
    access ~ ("." ~ identifier)*
}

// Power (right-associative): 2^3^4 = 2^(3^4)
power = {
    field_access ~ ("^" ~ power)?
}

// Unary operators: -x, !x
unary = {
    "-" ~ unary
  | "!" ~ unary
  | power
}

// Operators as separate rules (not silent, so they're captured)
mult_op = { "*" | "/" | "%" }
add_op = { "+" | "-" }
edge_op = { "->" | "<>" }
cmp_op = { "==" | "!=" | ">=" | "<=" | ">" | "<" }
logical_and_op = { "&&" }
logical_or_op = { "||" }

// Multiplicative: *, /, %
multiplicative = {
    unary ~ (mult_op ~ unary)*
}

// Additive: +, -
additive = {
    multiplicative ~ (add_op ~ multiplicative)*
}

// Edge: A -> B or A -- B with optional metadata
// Syntax: identifier edge_op identifier [":" expr]
edge = {
    additive ~ (edge_op ~ additive ~ (":" ~ additive)?)?
}

// Comparison: >, <, >=, <=, ==, !=
comparison = {
    edge ~ (cmp_op ~ edge)?
}

// Logical AND: &&
logical_and = {
    comparison ~ (logical_and_op ~ comparison)*
}

// Logical OR: ||
logical_or = {
    logical_and ~ (logical_or_op ~ logical_and)*
}

// Expression (entry point for expressions)
expr = { logical_or }

// ============================================================================
// Statements
// ============================================================================

// Let statement: let x = 42
let_statement = {
    "let" ~ identifier ~ "=" ~ expr
}

// Statement: either let or expression
statement = {
    let_statement
  | expr
}

// ============================================================================
// Program (entry point)
// ============================================================================

// Program: sequence of statements
program = {
    SOI ~ statement* ~ EOI
}
