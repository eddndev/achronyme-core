// ============================================================================
// Achronyme SOC Language Grammar (Pest PEG)
// ============================================================================
// This grammar defines the complete syntax for the SOC (Second-Order Calculus)
// language used by Achronyme for mathematical computations.
//
// Features:
// - Arithmetic expressions with proper precedence
// - Boolean literals and logical operators (&&, ||, !)
// - Comparison operators (>, <, >=, <=, ==, !=)
// - Conditional expressions (if function)
// - Function calls (sin, cos, map, etc.)
// - Vectors and matrices
// - Lambda functions with closures
// - Variable declarations (let)
// - Higher-order functions
// - Complex numbers (3i, 2+3i)
// - String literals with escape sequences
// - Records (key-value pairs)
// - Edges and networks (A -> B, A -- B)
// ============================================================================

// ============================================================================
// Whitespace and Comments
// ============================================================================

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* }

// ============================================================================
// Literals
// ============================================================================

// Boolean literals: true, false
boolean = { "true" | "false" }

// Numbers: 123, 3.14, -42, 1.5e-10, 2.5E+3
// Use negative lookahead to prevent matching "5." when followed by another "." (for ranges like "5..")
number = @{
    "-"? ~ ASCII_DIGIT+ ~ ("." ~ !"." ~ ASCII_DIGIT+)? ~ (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}

// Complex numbers: 3i, -2i
// Note: Full complex (2+3i) is handled as arithmetic expression
complex = @{ number ~ "i" }

// String literals: "hello", "world"
// Supports escape sequences: \n, \t, \r, \\, \"
string_literal = @{
    "\"" ~ string_char* ~ "\""
}

string_char = {
    !("\"" | "\\") ~ ANY
  | "\\" ~ ("\"" | "\\" | "n" | "t" | "r")
}

// Reserved keywords (use word boundaries to prevent matching prefixes)
keyword = _{
    ("let" | "mut" | "rec" | "self" | "true" | "false" | "import" | "from" | "export" | "as") ~ !ASCII_ALPHANUMERIC
}

// Identifiers: x, foo, my_var, PI, sin (but not keywords)
identifier = @{
    !keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")*
}

// Field identifier: like identifier but allows keywords (for field access like e.from)
field_identifier = @{
    (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")*
}

// ============================================================================
// Composite Literals
// ============================================================================

// Spread expression: ...expr
spread_expr = {
    "..." ~ expr
}

// Array (N-dimensional tensor): [1, 2, 3], [[1, 2], [3, 4]], [[[1,2],[3,4]], [[5,6],[7,8]]], []
// This is now recursive to support arbitrary tensor dimensions
// Allow empty arrays with optional expression list
// Arrays can now contain spread expressions: [1, ...vec, 2]
array_element = { spread_expr | expr }

array = {
    "[" ~ (array_element ~ ("," ~ array_element)*)? ~ "]"
}

// Vector and Matrix are now aliases for the unified array syntax
vector = { array }
matrix = { array }

// Record: { name: "Alice", age: 30, city: "Madrid" }
// Records can now contain spread expressions: { a: 1, ...other, b: 2 }
record_field_or_spread = { spread_expr | record_field }

record = {
    "{" ~ (record_field_or_spread ~ ("," ~ record_field_or_spread)*)? ~ "}"
}

// Mutable field keyword
mut_keyword = @{ "mut" ~ !ASCII_ALPHANUMERIC }

record_field = {
    (mut_keyword ~ identifier ~ ":" ~ expr)  // Mutable field: mut valor: 10
  | (identifier ~ ":" ~ expr)                // Immutable field: valor: 10
}

// ============================================================================
// Lambda Functions and Do Blocks
// ============================================================================

// Lambda parameters: x or (x, y, z) or ()
lambda_params = {
    identifier                                       // Single param: x
  | ("(" ~ (identifier ~ ("," ~ identifier)*)? ~ ")") // Multi param or no params: (x, y) or ()
}

// ============================================================================
// Unified Block System
// ============================================================================
// Blocks can contain a sequence of statements or a single expression
// Used by: do blocks, if expressions, match expressions (future), etc.

// Generic block: { sequence or statement }
// The last value in the block is its return value
// statement includes expr, so this covers all cases
block = {
    "{" ~ (sequence | statement) ~ "}"
}

// Do block: do { ... }
// Explicit block expression with "do" keyword
do_block = {
    "do" ~ block
}

// Lambda body: can be an expression or a do block
lambda_body = {
    do_block | expr
}

// Lambda: x => x^2 or (x, y) => x + y or x => do { ... }
lambda = {
    lambda_params ~ "=>" ~ lambda_body
}

// ============================================================================
// Control Flow Expressions
// ============================================================================
// Extensible system for control flow: if, match (future), while (future), etc.

// Control flow expression: currently only if, extensible for match, while, for, etc.
control_flow_expr = {
    if_expr
    // Future: | match_expr | while_expr | for_expr
}

// If expression: if(condition) { block } else { block }
// The condition MUST be in parentheses to avoid ambiguity with function calls
// Positive lookahead &"{" ensures we don't confuse with if(cond, then, else) function
if_expr = {
    "if" ~ "(" ~ expr ~ ")" ~ &"{" ~ block ~
    ("else" ~ (if_expr | block))?
}

// ============================================================================
// Function Calls
// ============================================================================

// ============================================================================
// Expressions (with operator precedence)
// ============================================================================

// Self-reference (for use in records) - use word boundary
self_ref = { "self" ~ !ASCII_ALPHANUMERIC }

// Rec-reference (for recursive function calls) - use word boundary
rec_ref = { "rec" ~ !ASCII_ALPHANUMERIC }

// Primary expressions (highest precedence)
// IMPORTANT: Order matters in PEG! More specific rules must come before general ones
primary = {
    boolean            // Boolean literals
  | string_literal     // String literals
  | complex            // Must come before number (3i contains number)
  | number
  | control_flow_expr  // Control flow (if, match, etc.) - before record to avoid ambiguity
  | record             // Record literals { key: value }
  | array              // Arrays/tensors (vectors, matrices, and higher-dimensional)
  | do_block           // Do blocks (must come before lambda to avoid ambiguity)
  | lambda
  | self_ref           // Self-reference in records
  | rec_ref            // Rec-reference for recursive calls
  | identifier
  | "(" ~ expr ~ ")"
}

// Range expression for slicing: start..end, start.., ..end, ..
// We need to be explicit to avoid ambiguity with the greedy PEG parser
range_expr = {
    expr ~ ".." ~ expr  // start..end
  | expr ~ ".."          // start..
  | ".." ~ expr          // ..end
  | ".."                 // ..
}

// Access argument: can be an index expression or a range for slicing
// Try range_expr first since it's more specific
access_arg = {
    range_expr | expr
}

// Postfix Expressions: unified rule for member access, indexing, and function calls.
// This is the key fix that allows for arbitrary chaining of these operations,
// e.g., obj.field[index](args), by treating them as left-associative postfix operators.
postfix_expression = {
    primary ~ postfix_op*
}

postfix_op = {
    call_op | index_op | field_op
}

call_op = { "(" ~ (expr ~ ("," ~ expr)*)? ~ ")" }
index_op = { "[" ~ access_arg ~ ("," ~ access_arg)* ~ "]" }
field_op = { "." ~ field_identifier }

// Power (right-associative): 2^3^4 = 2^(3^4)
power = {
    postfix_expression ~ ("^" ~ power)?
}

// Unary operators: -x, !x
unary = {
    "-" ~ unary
  | "!" ~ unary
  | power
}

// Operators as separate rules (not silent, so they're captured)
mult_op = { "*" | "/" | "%" }
add_op = { "+" | "-" }
edge_op = { "->" | "<>" }
cmp_op = { "==" | "!=" | ">=" | "<=" | ">" | "<" }
logical_and_op = { "&&" }
logical_or_op = { "||" }

// Multiplicative: *, /, %
multiplicative = {
    unary ~ (mult_op ~ unary)*
}

// Additive: +, -
additive = {
    multiplicative ~ (add_op ~ multiplicative)*
}

// Edge: A -> B or A -- B with optional metadata
// Syntax: identifier edge_op identifier [":" expr]
edge = {
    additive ~ (edge_op ~ additive ~ (":" ~ additive)?)?
}

// Comparison: >, <, >=, <=, ==, !=
comparison = {
    edge ~ (cmp_op ~ edge)?
}

// Logical AND: &&
logical_and = {
    comparison ~ (logical_and_op ~ comparison)*
}

// Logical OR: ||
logical_or = {
    logical_and ~ (logical_or_op ~ logical_and)*
}

// Expression (entry point for expressions)
expr = { logical_or }

// ============================================================================
// Import/Export Statements
// ============================================================================

// Import item: can be a simple identifier or an aliased import
// Examples: foo, foo as bar
import_item = {
    identifier ~ ("as" ~ identifier)?
}

// Import list: { foo, bar, baz as qux }
import_list = {
    "{" ~ import_item ~ ("," ~ import_item)* ~ "}"
}

// Module path: a string literal representing the module path
// Examples: "math", "stats", "./my_module", "../utils/helpers"
module_path = { string_literal }

// Import statement: import { sin, cos } from "math"
// Also supports: import { mean as average } from "stats"
import_statement = {
    "import" ~ import_list ~ "from" ~ module_path
}

// Export statement: export { foo, bar }
// For future use when we support user-defined modules
export_statement = {
    "export" ~ import_list
}

// ============================================================================
// Statements
// ============================================================================

// Let statement: let x = 42
let_statement = {
    "let" ~ identifier ~ "=" ~ expr
}

// Mut statement: mut x = 42
mut_statement = {
    "mut" ~ identifier ~ "=" ~ expr
}

// Assignment: x = 20, obj.field = 30, arr[0] = 40
// Uses postfix_expression as target for maximum flexibility
// Semantic validation happens in evaluator
assignment = {
    postfix_expression ~ "=" ~ expr
}

// Statement: import, export, let, mut, assignment, or expression
// Try import/export first, then assignment before expr to avoid ambiguity
statement = {
    import_statement
  | export_statement
  | let_statement
  | mut_statement
  | assignment
  | expr
}

// Sequence: multiple statements separated by semicolons
// Examples: "let a = 1; let b = 2; a + b" or "1 + 1; 2 + 2"
// The last statement doesn't need a semicolon
sequence = {
    statement ~ (";" ~ statement)+ ~ ";"?
}

// Top-level expression: either a sequence or a single statement
top_level_expr = {
    sequence | statement
}

// ============================================================================
// Program (entry point)
// ============================================================================

// Program: sequence of top-level expressions (for REPL compatibility)
program = {
    SOI ~ top_level_expr* ~ EOI
}
