/**
 * RustBindings.ts
 *
 * Type-safe bindings for Rust WASM module (wasm-bindgen)
 * Wraps all Rust functions with proper error handling and type conversions
 */

import type { Handle } from '../types';

// Import Rust WASM module generated by wasm-bindgen
import * as wasm from '../../../dist/achronyme_wasm.js';

/**
 * Rust WASM module interface
 * Provides type-safe access to all Rust functions
 */
export class RustWASM {
    private module: typeof wasm | null = null;
    private initialized = false;

    /**
     * Initialize the WASM module
     */
    async init(): Promise<void> {
        if (this.initialized) return;

        try {
            await wasm.default();
            this.module = wasm;
            this.initialized = true;
        } catch (error) {
            throw new Error(`Failed to initialize WASM module: ${error}`);
        }
    }

    /**
     * Ensure module is initialized
     */
    private ensureInit(): typeof wasm {
        if (!this.module || !this.initialized) {
            throw new Error('WASM module not initialized. Call init() first.');
        }
        return this.module;
    }

    // ========================================================================
    // Handle Management
    // ========================================================================

    /**
     * Release a handle in WASM memory
     */
    releaseHandle(handle: Handle): void {
        const mod = this.ensureInit();
        try {
            mod.reset();
        } catch (error) {
            console.warn(`Failed to release handle ${handle}:`, error);
        }
    }

    /**
     * Reset all handles (clear WASM memory)
     */
    reset(): void {
        const mod = this.ensureInit();
        mod.reset();
    }

    // ========================================================================
    // Type Constructors
    // ========================================================================

    /**
     * Create vector from JavaScript array
     * @returns Handle to the vector
     */
    createVector(data: number[]): Handle {
        const mod = this.ensureInit();
        try {
            return mod.createVector(data);
        } catch (error) {
            throw new Error(`Failed to create vector: ${error}`);
        }
    }

    /**
     * Get vector data (for extraction/verification)
     */
    getVector(handle: Handle): number[] {
        const mod = this.ensureInit();
        try {
            return mod.getVector(handle);
        } catch (error) {
            throw new Error(`Failed to get vector: ${error}`);
        }
    }

    /**
     * Get vector length
     */
    getVectorLength(handle: Handle): number {
        const mod = this.ensureInit();
        try {
            const data = mod.getVector(handle);
            return data.length;
        } catch (error) {
            throw new Error(`Failed to get vector length: ${error}`);
        }
    }

    // ========================================================================
    // Math Operations (Fast Path)
    // ========================================================================

    sin_fast(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.sin_fast(handle);
        } catch (error) {
            throw new Error(`sin_fast failed: ${error}`);
        }
    }

    cos_fast(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.cos_fast(handle);
        } catch (error) {
            throw new Error(`cos_fast failed: ${error}`);
        }
    }

    tan_fast(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.tan_fast(handle);
        } catch (error) {
            throw new Error(`tan_fast failed: ${error}`);
        }
    }

    exp_fast(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.exp_fast(handle);
        } catch (error) {
            throw new Error(`exp_fast failed: ${error}`);
        }
    }

    ln_fast(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.ln_fast(handle);
        } catch (error) {
            throw new Error(`ln_fast failed: ${error}`);
        }
    }

    abs_fast(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.abs_fast(handle);
        } catch (error) {
            throw new Error(`abs_fast failed: ${error}`);
        }
    }

    sqrt_fast(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.sqrt_fast(handle);
        } catch (error) {
            throw new Error(`sqrt_fast failed: ${error}`);
        }
    }

    // ========================================================================
    // DSP Operations (Fast Path)
    // ========================================================================

    fft_fast(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.fft_fast(handle);
        } catch (error) {
            throw new Error(`fft_fast failed: ${error}`);
        }
    }

    fft_mag_fast(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.fft_mag_fast(handle);
        } catch (error) {
            throw new Error(`fft_mag_fast failed: ${error}`);
        }
    }

    ifft_fast(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.ifft_fast(handle);
        } catch (error) {
            throw new Error(`ifft_fast failed: ${error}`);
        }
    }

    // ========================================================================
    // Linear Algebra Operations (Fast Path)
    // ========================================================================

    /**
     * LU Decomposition
     * @returns Object with handles to L, U, P matrices
     */
    lu_decomposition_js(handle: Handle): { L: Handle; U: Handle; P: Handle } {
        const mod = this.ensureInit();
        try {
            return mod.lu_decomposition_js(handle);
        } catch (error) {
            throw new Error(`lu_decomposition_js failed: ${error}`);
        }
    }

    /**
     * QR Decomposition
     * @returns Object with handles to Q, R matrices
     */
    qr_decomposition_js(handle: Handle): { Q: Handle; R: Handle } {
        const mod = this.ensureInit();
        try {
            return mod.qr_decomposition_js(handle);
        } catch (error) {
            throw new Error(`qr_decomposition_js failed: ${error}`);
        }
    }

    /**
     * SVD Decomposition
     * @returns Object with handles to U, S (vector), V matrices
     */
    svd_decomposition_js(handle: Handle): { U: Handle; S: Handle; V: Handle } {
        const mod = this.ensureInit();
        try {
            return mod.svd_decomposition_js(handle);
        } catch (error) {
            throw new Error(`svd_decomposition_js failed: ${error}`);
        }
    }

    // ========================================================================
    // Utility Functions
    // ========================================================================

    linspace_fast(start: number, stop: number, num: number): Handle {
        const mod = this.ensureInit();
        try {
            return mod.linspace_fast(start, stop, num);
        } catch (error) {
            throw new Error(`linspace_fast failed: ${error}`);
        }
    }

    // ========================================================================
    // Expression Evaluation (Slow Path)
    // ========================================================================

    /**
     * Evaluate expression string (Slow Path)
     * Uses Rust parser/evaluator
     */
    _eval(expr: string): Handle {
        const mod = this.ensureInit();
        try {
            return mod._eval(expr);
        } catch (error) {
            throw new Error(`_eval failed: ${error}`);
        }
    }
}

/**
 * Singleton instance of RustWASM
 * Exported for convenience
 */
export const rustWASM = new RustWASM();
