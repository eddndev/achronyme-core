/**
 * RustBindings.ts
 *
 * Type-safe bindings for Rust WASM module (wasm-bindgen)
 * Wraps all Rust functions with proper error handling and type conversions
 */

import type { Handle } from '../types';

// Import Rust WASM module generated by wasm-bindgen
// The default export is the init function, named exports are the WASM functions
import initWasm, * as wasmBindings from '../../../dist/achronyme_wasm.js';

/**
 * Rust WASM module interface
 * Provides type-safe access to all Rust functions
 */
export class RustWASM {
    private module: typeof wasmBindings | null = null;
    private initialized = false;

    /**
     * Initialize the WASM module
     */
    async init(): Promise<void> {
        if (this.initialized) return;

        try {
            // Call the default init function to load and initialize WASM
            // This sets up the internal wasm instance that all exported functions use
            await initWasm();

            // Store reference to the WASM bindings
            this.module = wasmBindings;
            this.initialized = true;
        } catch (error) {
            throw new Error(`Failed to initialize WASM module: ${error}`);
        }
    }

    /**
     * Ensure module is initialized
     */
    private ensureInit(): typeof wasmBindings {
        if (!this.module || !this.initialized) {
            throw new Error('WASM module not initialized. Call init() first.');
        }
        return this.module;
    }

    // ========================================================================
    // Handle Management
    // ========================================================================

    /**
     * Release a handle in WASM memory
     */
    releaseHandle(handle: Handle): void {
        const mod = this.ensureInit();
        try {
            mod.releaseHandle(handle);
        } catch (error) {
            console.warn(`Failed to release handle ${handle}:`, error);
        }
    }

    /**
     * Reset all handles (clear WASM memory)
     */
    reset(): void {
        const mod = this.ensureInit();
        mod.reset();
    }

    // ========================================================================
    // Type Constructors
    // ========================================================================

    /**
     * Create vector from JavaScript array
     * @returns Handle to the vector
     */
    createVector(data: number[]): Handle {
        const mod = this.ensureInit();
        try {
            return mod.createVector(data);
        } catch (error) {
            throw new Error(`Failed to create vector: ${error}`);
        }
    }

    /**
     * Get vector data (for extraction/verification)
     */
    getVector(handle: Handle): number[] {
        const mod = this.ensureInit();
        try {
            return mod.getVector(handle);
        } catch (error) {
            throw new Error(`Failed to get vector: ${error}`);
        }
    }

    /**
     * Get vector length
     */
    getVectorLength(handle: Handle): number {
        const mod = this.ensureInit();
        try {
            const data = mod.getVector(handle);
            return data.length;
        } catch (error) {
            throw new Error(`Failed to get vector length: ${error}`);
        }
    }

    /**
     * Create matrix from JavaScript array (row-major order)
     * @param data Flattened array in row-major order
     * @param rows Number of rows
     * @param cols Number of columns
     * @returns Handle to the matrix
     */
    createMatrix(data: number[], rows: number, cols: number): Handle {
        const mod = this.ensureInit();
        try {
            return mod.createMatrix(data, rows, cols);
        } catch (error) {
            throw new Error(`Failed to create matrix: ${error}`);
        }
    }

    // ========================================================================
    // Math Operations
    // ========================================================================

    sin(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.mathSin(handle);
        } catch (error) {
            throw new Error(`sin failed: ${error}`);
        }
    }

    cos(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.mathCos(handle);
        } catch (error) {
            throw new Error(`cos failed: ${error}`);
        }
    }

    tan(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.mathTan(handle);
        } catch (error) {
            throw new Error(`tan failed: ${error}`);
        }
    }

    exp(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.mathExp(handle);
        } catch (error) {
            throw new Error(`exp failed: ${error}`);
        }
    }

    ln(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.mathLn(handle);
        } catch (error) {
            throw new Error(`ln failed: ${error}`);
        }
    }

    abs(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.mathAbs(handle);
        } catch (error) {
            throw new Error(`abs failed: ${error}`);
        }
    }

    sqrt(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.mathSqrt(handle);
        } catch (error) {
            throw new Error(`sqrt failed: ${error}`);
        }
    }

    // ========================================================================
    // DSP Operations
    // ========================================================================

    fft(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.dspFft(handle);
        } catch (error) {
            throw new Error(`fft failed: ${error}`);
        }
    }

    fft_mag(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.dspFftMag(handle);
        } catch (error) {
            throw new Error(`fft_mag failed: ${error}`);
        }
    }

    ifft(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.ifft(handle);
        } catch (error) {
            throw new Error(`ifft failed: ${error}`);
        }
    }

    hanningWindow(n: number): Handle {
        const mod = this.ensureInit();
        try {
            return mod.hanningWindow(n);
        } catch (error) {
            throw new Error(`hanningWindow failed: ${error}`);
        }
    }

    hammingWindow(n: number): Handle {
        const mod = this.ensureInit();
        try {
            return mod.hammingWindow(n);
        } catch (error) {
            throw new Error(`hammingWindow failed: ${error}`);
        }
    }

    blackmanWindow(n: number): Handle {
        const mod = this.ensureInit();
        try {
            return mod.blackmanWindow(n);
        } catch (error) {
            throw new Error(`blackmanWindow failed: ${error}`);
        }
    }

    // ========================================================================
    // Linear Algebra Operations (Fast Path)
    // ========================================================================

    /**
     * LU Decomposition
     * @returns Object with handles to L, U, P matrices
     */
    lu_decomposition_js(handle: Handle): { L: Handle; U: Handle; P: Handle } {
        const mod = this.ensureInit();
        try {
            return mod.lu(handle);
        } catch (error) {
            throw new Error(`lu_decomposition_js failed: ${error}`);
        }
    }

    /**
     * QR Decomposition
     * @returns Object with handles to Q, R matrices
     */
    qr_decomposition_js(handle: Handle): { Q: Handle; R: Handle } {
        const mod = this.ensureInit();
        try {
            return mod.qr(handle);
        } catch (error) {
            throw new Error(`qr_decomposition_js failed: ${error}`);
        }
    }

    /**
     * SVD Decomposition
     * @returns Object with handles to U, S (vector), V matrices
     */
    svd_decomposition_js(handle: Handle): { U: Handle; S: Handle; V: Handle } {
        const mod = this.ensureInit();
        try {
            return mod.svd(handle);
        } catch (error) {
            throw new Error(`svd_decomposition_js failed: ${error}`);
        }
    }

    /**
     * Matrix Inverse
     * @returns Handle to inverse matrix
     */
    matrixInverse(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.inverse(handle);
        } catch (error) {
            throw new Error(`Matrix inverse failed: ${error}`);
        }
    }

    // ========================================================================
    // Vector Operations
    // ========================================================================

    vadd(handle1: Handle, handle2: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.vadd(handle1, handle2);
        } catch (error) {
            throw new Error(`vadd failed: ${error}`);
        }
    }

    vsub(handle1: Handle, handle2: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.vsub(handle1, handle2);
        } catch (error) {
            throw new Error(`vsub failed: ${error}`);
        }
    }

    vmul(handle1: Handle, handle2: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.vmul(handle1, handle2);
        } catch (error) {
            throw new Error(`vmul failed: ${error}`);
        }
    }

    vdiv(handle1: Handle, handle2: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.vdiv(handle1, handle2);
        } catch (error) {
            throw new Error(`vdiv failed: ${error}`);
        }
    }

    dot(handle1: Handle, handle2: Handle): number {
        const mod = this.ensureInit();
        try {
            return mod.dot(handle1, handle2);
        } catch (error) {
            throw new Error(`dot failed: ${error}`);
        }
    }

    norm(handle: Handle): number {
        const mod = this.ensureInit();
        try {
            return mod.norm(handle);
        } catch (error) {
            throw new Error(`norm failed: ${error}`);
        }
    }

    norm_l1(handle: Handle): number {
        const mod = this.ensureInit();
        try {
            return mod.norm_l1(handle);
        } catch (error) {
            throw new Error(`norm_l1 failed: ${error}`);
        }
    }

    // ========================================================================
    // Statistics Operations
    // ========================================================================

    sum(handle: Handle): number {
        const mod = this.ensureInit();
        try {
            return mod.sum(handle);
        } catch (error) {
            throw new Error(`sum failed: ${error}`);
        }
    }

    mean(handle: Handle): number {
        const mod = this.ensureInit();
        try {
            return mod.mean(handle);
        } catch (error) {
            throw new Error(`mean failed: ${error}`);
        }
    }

    std(handle: Handle): number {
        const mod = this.ensureInit();
        try {
            return mod.std(handle);
        } catch (error) {
            throw new Error(`std failed: ${error}`);
        }
    }

    min(handle: Handle): number {
        const mod = this.ensureInit();
        try {
            return mod.min(handle);
        } catch (error) {
            throw new Error(`min failed: ${error}`);
        }
    }

    max(handle: Handle): number {
        const mod = this.ensureInit();
        try {
            return mod.max(handle);
        } catch (error) {
            throw new Error(`max failed: ${error}`);
        }
    }

    // ========================================================================
    // Utility Functions
    // ========================================================================

    linspace(start: number, stop: number, num: number): Handle {
        const mod = this.ensureInit();
        try {
            return mod.linspace(start, stop, num);
        } catch (error) {
            throw new Error(`linspace failed: ${error}`);
        }
    }

    // ========================================================================
    // Expression Evaluation (Slow Path)
    // ========================================================================

    /**
     * Evaluate expression string (Slow Path)
     * Uses Rust parser/evaluator
     */
    _eval(expr: string): Handle {
        const mod = this.ensureInit();
        try {
            return mod._eval(expr);
        } catch (error) {
            throw new Error(`_eval failed: ${error}`);
        }
    }
}

/**
 * Singleton instance of RustWASM
 * Exported for convenience
 */
export const rustWASM = new RustWASM();
