/**
 * RustBindings.ts
 *
 * Type-safe bindings for Rust WASM module (wasm-bindgen)
 * Wraps all Rust functions with proper error handling and type conversions
 */

import type { Handle } from '../types';

// Import Rust WASM module generated by wasm-bindgen
// With target=bundler, the module auto-initializes (no init function needed)
import * as wasmBindings from '../../../dist/achronyme_wasm.js';

/**
 * Rust WASM module interface
 * Provides type-safe access to all Rust functions
 */
export class RustWASM {
    private module: typeof wasmBindings | null = null;
    private initialized = false;

    /**
     * Initialize the WASM module
     *
     * With target=bundler, the WASM module auto-initializes
     * We need to wait a tick to ensure it's ready
     */
    async init(): Promise<void> {
        if (this.initialized) return;

        try {
            // With bundler target, module initializes on import
            // Wait a microtask to ensure WASM is ready
            await Promise.resolve();

            // Verify the module has exports
            if (!wasmBindings || typeof wasmBindings.createVector !== 'function') {
                throw new Error('WASM module not properly initialized - functions not available');
            }

            this.module = wasmBindings;
            this.initialized = true;

            console.log('✅ RustWASM initialized successfully');
        } catch (error) {
            console.error('❌ Failed to initialize WASM module:', error);
            throw new Error(`Failed to initialize WASM module: ${error}`);
        }
    }

    /**
     * Ensure module is initialized
     */
    private ensureInit(): typeof wasmBindings {
        if (!this.module || !this.initialized) {
            throw new Error('WASM module not initialized. Call init() first.');
        }
        return this.module;
    }

    // ========================================================================
    // Handle Management
    // ========================================================================

    /**
     * Release a handle in WASM memory
     */
    releaseHandle(handle: Handle): void {
        const mod = this.ensureInit();
        try {
            mod.releaseHandle(handle);
        } catch (error) {
            console.warn(`Failed to release handle ${handle}:`, error);
        }
    }

    /**
     * Reset all handles (clear WASM memory)
     */
    reset(): void {
        const mod = this.ensureInit();
        mod.reset();
    }

    // ========================================================================
    // Type Constructors
    // ========================================================================

    /**
     * Create vector from JavaScript array
     * @returns Handle to the vector
     */
    createVector(data: number[]): Handle {
        const mod = this.ensureInit();
        try {
            // Convert to Float64Array for WASM
            const float64Data = new Float64Array(data);
            return mod.createVector(float64Data);
        } catch (error) {
            throw new Error(`Failed to create vector: ${error}`);
        }
    }

    /**
     * Get vector data (for extraction/verification)
     */
    getVector(handle: Handle): number[] {
        const mod = this.ensureInit();
        try {
            const float64Array = mod.getVector(handle);
            // Convert Float64Array to regular array
            return Array.from(float64Array);
        } catch (error) {
            throw new Error(`Failed to get vector: ${error}`);
        }
    }

    /**
     * Get vector length
     */
    getVectorLength(handle: Handle): number {
        const mod = this.ensureInit();
        try {
            const data = mod.getVector(handle);
            return data.length;
        } catch (error) {
            throw new Error(`Failed to get vector length: ${error}`);
        }
    }

    /**
     * Create matrix from JavaScript array (row-major order)
     * @param data Flattened array in row-major order
     * @param rows Number of rows
     * @param cols Number of columns
     * @returns Handle to the matrix
     */
    createMatrix(data: number[], rows: number, cols: number): Handle {
        const mod = this.ensureInit();
        try {
            // Convert to Float64Array for WASM
            const float64Data = new Float64Array(data);
            return mod.createMatrix(float64Data, rows, cols);
        } catch (error) {
            throw new Error(`Failed to create matrix: ${error}`);
        }
    }

    // ========================================================================
    // Math Operations
    // ========================================================================

    sin(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.mathSin(handle);
        } catch (error) {
            throw new Error(`sin failed: ${error}`);
        }
    }

    cos(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.mathCos(handle);
        } catch (error) {
            throw new Error(`cos failed: ${error}`);
        }
    }

    tan(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.mathTan(handle);
        } catch (error) {
            throw new Error(`tan failed: ${error}`);
        }
    }

    exp(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.mathExp(handle);
        } catch (error) {
            throw new Error(`exp failed: ${error}`);
        }
    }

    ln(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.mathLn(handle);
        } catch (error) {
            throw new Error(`ln failed: ${error}`);
        }
    }

    abs(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.mathAbs(handle);
        } catch (error) {
            throw new Error(`abs failed: ${error}`);
        }
    }

    sqrt(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.mathSqrt(handle);
        } catch (error) {
            throw new Error(`sqrt failed: ${error}`);
        }
    }

    // ========================================================================
    // DSP Operations
    // ========================================================================

    fft(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.dspFft(handle);
        } catch (error) {
            throw new Error(`fft failed: ${error}`);
        }
    }

    fft_mag(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.dspFftMag(handle);
        } catch (error) {
            throw new Error(`fft_mag failed: ${error}`);
        }
    }

    ifft(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.ifft(handle);
        } catch (error) {
            throw new Error(`ifft failed: ${error}`);
        }
    }

    hanningWindow(n: number): Handle {
        const mod = this.ensureInit();
        try {
            return mod.hanningWindow(n);
        } catch (error) {
            throw new Error(`hanningWindow failed: ${error}`);
        }
    }

    hammingWindow(n: number): Handle {
        const mod = this.ensureInit();
        try {
            return mod.hammingWindow(n);
        } catch (error) {
            throw new Error(`hammingWindow failed: ${error}`);
        }
    }

    blackmanWindow(n: number): Handle {
        const mod = this.ensureInit();
        try {
            return mod.blackmanWindow(n);
        } catch (error) {
            throw new Error(`blackmanWindow failed: ${error}`);
        }
    }

    // ========================================================================
    // Linear Algebra Operations (Fast Path)
    // ========================================================================

    /**
     * LU Decomposition
     * @returns Object with handles to L, U, P matrices
     */
    lu_decomposition_js(handle: Handle): { L: Handle; U: Handle; P: Handle } {
        const mod = this.ensureInit();
        try {
            return mod.lu(handle);
        } catch (error) {
            throw new Error(`lu_decomposition_js failed: ${error}`);
        }
    }

    /**
     * QR Decomposition
     * @returns Object with handles to Q, R matrices
     */
    qr_decomposition_js(handle: Handle): { Q: Handle; R: Handle } {
        const mod = this.ensureInit();
        try {
            return mod.qr(handle);
        } catch (error) {
            throw new Error(`qr_decomposition_js failed: ${error}`);
        }
    }

    /**
     * SVD Decomposition
     * @returns Object with handles to U, S (vector), V matrices
     */
    svd_decomposition_js(handle: Handle): { U: Handle; S: Handle; V: Handle } {
        const mod = this.ensureInit();
        try {
            return mod.svd(handle);
        } catch (error) {
            throw new Error(`svd_decomposition_js failed: ${error}`);
        }
    }

    /**
     * Matrix Inverse
     * @returns Handle to inverse matrix
     */
    matrixInverse(handle: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.inverse(handle);
        } catch (error) {
            throw new Error(`Matrix inverse failed: ${error}`);
        }
    }

    // ========================================================================
    // Vector Operations
    // ========================================================================

    vadd(handle1: Handle, handle2: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.vadd(handle1, handle2);
        } catch (error) {
            throw new Error(`vadd failed: ${error}`);
        }
    }

    vsub(handle1: Handle, handle2: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.vsub(handle1, handle2);
        } catch (error) {
            throw new Error(`vsub failed: ${error}`);
        }
    }

    vmul(handle1: Handle, handle2: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.vmul(handle1, handle2);
        } catch (error) {
            throw new Error(`vmul failed: ${error}`);
        }
    }

    vdiv(handle1: Handle, handle2: Handle): Handle {
        const mod = this.ensureInit();
        try {
            return mod.vdiv(handle1, handle2);
        } catch (error) {
            throw new Error(`vdiv failed: ${error}`);
        }
    }

    dot(handle1: Handle, handle2: Handle): number {
        const mod = this.ensureInit();
        try {
            return mod.dot(handle1, handle2);
        } catch (error) {
            throw new Error(`dot failed: ${error}`);
        }
    }

    norm(handle: Handle): number {
        const mod = this.ensureInit();
        try {
            return mod.norm(handle);
        } catch (error) {
            throw new Error(`norm failed: ${error}`);
        }
    }

    norm_l1(handle: Handle): number {
        const mod = this.ensureInit();
        try {
            return mod.norm_l1(handle);
        } catch (error) {
            throw new Error(`norm_l1 failed: ${error}`);
        }
    }

    // ========================================================================
    // Statistics Operations
    // ========================================================================

    sum(handle: Handle): number {
        const mod = this.ensureInit();
        try {
            return mod.sum(handle);
        } catch (error) {
            throw new Error(`sum failed: ${error}`);
        }
    }

    mean(handle: Handle): number {
        const mod = this.ensureInit();
        try {
            return mod.mean(handle);
        } catch (error) {
            throw new Error(`mean failed: ${error}`);
        }
    }

    std(handle: Handle): number {
        const mod = this.ensureInit();
        try {
            return mod.std(handle);
        } catch (error) {
            throw new Error(`std failed: ${error}`);
        }
    }

    min(handle: Handle): number {
        const mod = this.ensureInit();
        try {
            return mod.min(handle);
        } catch (error) {
            throw new Error(`min failed: ${error}`);
        }
    }

    max(handle: Handle): number {
        const mod = this.ensureInit();
        try {
            return mod.max(handle);
        } catch (error) {
            throw new Error(`max failed: ${error}`);
        }
    }

    // ========================================================================
    // Utility Functions
    // ========================================================================

    linspace(start: number, stop: number, num: number): Handle {
        const mod = this.ensureInit();
        try {
            return mod.linspace(start, stop, num);
        } catch (error) {
            throw new Error(`linspace failed: ${error}`);
        }
    }

    // ========================================================================
    // Expression Evaluation (Slow Path)
    // ========================================================================

    /**
     * Evaluate expression string (Slow Path)
     * Uses Rust parser/evaluator
     */
    _eval(expr: string): string {
        const mod = this.ensureInit();
        try {
            return mod._eval(expr);
        } catch (error) {
            throw new Error(`_eval failed: ${error}`);
        }
    }

    // ========================================================================
    // Numerical Calculus
    // ========================================================================

    /**
     * Numerical first derivative
     */
    numDiff(funcHandle: Handle, x: number, h: number): number {
        const mod = this.ensureInit();
        return mod.numDiff(funcHandle, x, h);
    }

    /**
     * Numerical second derivative
     */
    numDiff2(funcHandle: Handle, x: number, h: number): number {
        const mod = this.ensureInit();
        return mod.numDiff2(funcHandle, x, h);
    }

    /**
     * Numerical third derivative
     */
    numDiff3(funcHandle: Handle, x: number, h: number): number {
        const mod = this.ensureInit();
        return mod.numDiff3(funcHandle, x, h);
    }

    /**
     * Numerical integration (trapezoidal rule)
     */
    numIntegral(funcHandle: Handle, a: number, b: number, n: number): number {
        const mod = this.ensureInit();
        return mod.numIntegral(funcHandle, a, b, n);
    }

    /**
     * Numerical integration (Simpson's rule)
     */
    numSimpson(funcHandle: Handle, a: number, b: number, n: number): number {
        const mod = this.ensureInit();
        return mod.numSimpson(funcHandle, a, b, n);
    }

    /**
     * Romberg integration
     */
    numRomberg(funcHandle: Handle, a: number, b: number, tol: number): number {
        const mod = this.ensureInit();
        return mod.numRomberg(funcHandle, a, b, tol);
    }

    /**
     * Adaptive quadrature
     */
    numQuad(funcHandle: Handle, a: number, b: number): number {
        const mod = this.ensureInit();
        return mod.numQuad(funcHandle, a, b);
    }

    /**
     * Root finding (bisection method)
     */
    numSolve(funcHandle: Handle, a: number, b: number, tol: number): number {
        const mod = this.ensureInit();
        return mod.numSolve(funcHandle, a, b, tol);
    }

    /**
     * Root finding (Newton's method)
     */
    numNewton(
        funcHandle: Handle,
        dfuncHandle: Handle,
        x0: number,
        tol: number,
        maxIter: number
    ): number {
        const mod = this.ensureInit();
        return mod.numNewton(funcHandle, dfuncHandle, x0, tol, maxIter);
    }

    /**
     * Root finding (Secant method)
     */
    numSecant(
        funcHandle: Handle,
        x0: number,
        x1: number,
        tol: number,
        maxIter: number
    ): number {
        const mod = this.ensureInit();
        return mod.numSecant(funcHandle, x0, x1, tol, maxIter);
    }
}

/**
 * Singleton instance of RustWASM
 * Exported for convenience
 */
export const rustWASM = new RustWASM();
