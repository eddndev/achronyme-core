# Changelog - Version 0.5.x

This file contains all changes for the 0.5.x release series.

## [0.5.3] - 2025-11-06

### Added - Conditional Expressions & Piecewise Functions

**Boolean Logic & Conditionals:**

- **Boolean Type System**
  - New `Value::Boolean(bool)` variant in type system
  - Boolean literals: `true`, `false`
  - Automatic type conversion: `Number -> Boolean` (0 = false, non-zero = true)

- **Logical Operators**
  - AND operator: `&&` with short-circuit evaluation
  - OR operator: `||` with short-circuit evaluation
  - NOT operator: `!` for boolean negation
  - Operator precedence: `!` > `&&` > `||`

- **Comparison Operators (Enhanced)**
  - Now return `Boolean` type instead of `Number`
  - Operators: `>`, `<`, `>=`, `<=`, `==`, `!=`
  - Example: `5 > 3` returns `true` (not `1.0`)

- **`if()` Function - Conditional Expression**
  - Syntax: `if(condition, then_value, else_value)`
  - Short-circuit evaluation (only evaluates chosen branch)
  - Works with any expression type
  - Examples:
    ```javascript
    if(x > 0, x, -x)              // Absolute value
    if(x > 0, x, 0)               // ReLU activation
    if(x > 10, 2, 1)              // Conditional logic
    ```

**Piecewise Functions:**

- **`piecewise()` Function - Multi-Branch Conditionals**
  - Syntax: `piecewise([cond1, val1], [cond2, val2], ..., default)`
  - Sequential evaluation with short-circuit
  - Optional default value (last argument without `[]`)
  - Error if no condition matches and no default provided
  - Full support for multivariable lambdas

  - **Mathematical Applications:**
    ```javascript
    // Sign function
    let signo = x => piecewise([x < 0, -1], [x > 0, 1], 0)

    // Progressive tax brackets
    let tax = income => piecewise(
      [income <= 10000, income * 0.1],
      [income <= 50000, income * 0.2],
      income * 0.3
    )

    // Piecewise polynomial
    let f = x => piecewise([x < -1, x^2], [x < 1, 2*x + 1], x^3)

    // Heaviside step function
    let H = x => piecewise([x < 0, 0], 1)
    ```

**DSP & Signal Processing Integration:**

- **Classic Waveforms Implemented:**
  - Square Wave (FFT -> odd harmonics)
  - Sawtooth Wave, Triangle Wave
  - Rectangular Pulse (FFT -> sinc pattern)
  - Half-Wave & Full-Wave Rectifiers
  - Pulse Train (digital signals)

- **Numerical Analysis Validation:**
  - FFT: Spectral analysis of discontinuous signals
  - Differentiation: Correct derivatives at discontinuities
  - Integration: `trapz(relu, -1, 2, 100)` = 2.0 (exact)

**Testing & Validation:**

- **Unit Tests:** 92 total (20 new for conditionals/piecewise), all passing
- **DSP Integration:** Square wave FFT, rectifiers, numerical analysis
- **CLI Validation:** All example files execute correctly

**Example Files:**

- `examples/soc/15-conditionals.soc` - Boolean logic and `if()` expressions
- `examples/soc/16-piecewise.soc` - 14 piecewise function examples
- `examples/soc/17-piecewise-analysis.soc` - DSP + numerical analysis integration

**Use Cases Unlocked:**

1. **Mathematical Modeling:** Discontinuous functions, piecewise polynomials
2. **Digital Signal Processing:** Waveform generation, rectification, FFT analysis
3. **Machine Learning:** Activation functions (ReLU, Leaky ReLU)
4. **Economics:** Progressive tax systems, tiered pricing
5. **Physics & Engineering:** Boundary conditions, control systems

### Changed

- **Comparison Operators:** Now return `Value::Boolean` instead of `Value::Number`
- **Parser Cleanup:** Removed legacy hand-written parser (lexer.rs, parser.rs, token.rs)

### Breaking Changes

- Comparison operators return `Boolean` instead of `Number` (1.0/0.0)
- Migration: `filter()` automatically handles both boolean and numeric predicates

### Performance

- Boolean operations: <1us
- `if()` evaluation: <2us (short-circuit)
- `piecewise()`: <5us for 3 cases
- FFT of piecewise signals: ~1ms for 32 samples

---

### Added - Parser Migration to Pest

**Major Infrastructure Upgrade:**

- **Migrated Parser from Hand-Written to Pest (PEG Parser Generator)**
  - Replaced manual recursive descent parser with declarative Pest grammar
  - ~150 lines of clean PEG grammar vs ~1000+ lines of hand-written code
  - Better error messages with precise location information
  - Easier to extend with new language features
  - More robust handling of precedence and associativity

- **New Parser Module: `pest_parser.rs`**
  - Complete SOC language grammar in `grammar.pest`
  - Automatic tokenization and parsing via Pest macros
  - Clean AST generation from Pest pairs

- **New Evaluator API: `eval_str()`**
  - Direct string-to-value evaluation using Pest parser
  - Example: `evaluator.eval_str("2 + 3 * 4")` returns `Value::Number(14.0)`

- **Comprehensive Test Suite**
  - 8 parser-specific tests (all passing)
  - 12 evaluator integration tests (all passing)
  - Tests for comments, multi-line scripts, and SOC-style code

### Documentation - Linear Programming Standard Form

**Important Conventions for Optimization Functions:**

All LP solvers (`linprog`, `simplex`, `dual_simplex`, `revised_simplex`) use **standard form**:

```
maximize/minimize z = c^T * x
subject to: Ax <= b, x >= 0
```

**Key Points:**
- ALL constraints must be in `Ax <= b` form (less-than-or-equal)
- ALL values in vector `b` must be non-negative (b >= 0)
- User is responsible for converting problems to standard form

---

## [0.5.2] - 2025-11-05

### Added

- **Comprehensive Built-in Function Reference:** Added a detailed list of all functions available in the SOC language evaluator, now organized by domain.

  - **Trigonometric:** `sin`, `cos`, `tan`, `asin`, `acos`, `atan`, `atan2`, `sinh`, `cosh`, `tanh`
  - **Exponential & Logarithmic:** `exp`, `ln`, `log` (alias for ln), `log10`, `log2`, `sqrt`, `cbrt`, `pow`
  - **Rounding & Utility:** `floor`, `ceil`, `round`, `trunc`, `abs`, `sign`, `deg`, `rad`, `min`, `max`
  - **Complex Numbers:** `complex`, `real`, `imag`, `conj`, `arg`
  - **Vector Operations:** `dot`, `cross`, `norm`, `normalize`
  - **Matrix Operations:** `transpose`, `det`, `trace`
  - **Statistics:** `sum`, `mean`, `std`
  - **Digital Signal Processing (DSP):**
    - **FFT:** `fft`, `ifft`, `fft_mag`, `fft_phase`
    - **Convolution:** `conv`, `conv_fft`
    - **Windows:** `hanning`, `hamming`, `blackman`, `rectangular`
    - **Utilities:** `linspace`
  - **Optimization & Linear Programming:**
    - **Solvers:** `simplex`, `linprog`, `dual_simplex`, `two_phase_simplex`, `revised_simplex`
    - **Analysis:** `objective_value`, `shadow_price`, `sensitivity_b`, `sensitivity_c`

### Changed

- **Refactored `FunctionRegistry`:** Modularized the monolithic function registry into domain-specific modules (`trig`, `dsp`, `stats`, etc.) located in the `function_modules/` directory. This greatly improves organization, scalability, and maintainability, making it easier to add new function categories in the future.

---

## [0.5.1] - 2025-01-05

### Added - Numerical Calculus Module

**Complete Numerical Calculus Suite:**
- **Numerical Differentiation:**
  - `diff()` - First derivative using central difference method
  - `diff2()` - Second derivative
  - `diff3()` - Third derivative
  - Configurable step sizes for precision control

- **Numerical Integration:**
  - `integral()` - Trapezoidal rule integration
  - `simpson()` - Simpson's 1/3 rule (higher accuracy)
  - `romberg()` - Romberg integration with Richardson extrapolation
  - `quad()` - Adaptive quadrature for automatic accuracy

- **Root Finding:**
  - `solve()` - Bisection method for bracketed roots
  - `newton()` - Newton's method (requires derivative)
  - `secant()` - Secant method (no derivative needed)

**Architecture Improvements:**
- **Dependency Injection Pattern** via `LambdaEvaluator` trait:
  - Decouples numerical algorithms from expression evaluator
  - Enables multiple evaluation backends (JIT, GPU, caching, etc.)
  - Simplifies testing with mock evaluators
  - Resolves Rust borrow checker conflicts elegantly

- **Multi-Parameter Lambda Support:**
  - Extended `LambdaEvaluator` with `eval_at_nd()` for N-dimensional functions
  - Foundation for future ODEs, optimization, and multivariate calculus
  - Full support for `(x, y) => x^2 + y^2` style lambdas

**WASM Bindings:**
- New `evalToHandle()` function - evaluates SOC expressions and returns handles
- 10 new numerical function exports: `numDiff`, `numDiff2`, `numDiff3`, `numIntegral`, `numSimpson`, `numRomberg`, `numQuad`, `numSolve`, `numNewton`, `numSecant`

**TypeScript SDK:**
- New `NumericalOps` module with complete JSDoc documentation
- Clean API accepting SOC expression strings: `numerical.diff('x => x^2', 2)`
- All functions return numbers or throw descriptive errors
- Example usage in interactive demo with 11 comprehensive tests

**Testing:**
- SOC script tests for all numerical functions
- Interactive demo category with visual results
- Validated against analytical solutions (derivatives, integrals, roots)
- All tests passing with 6-decimal precision

### Technical Details
- **Modular Architecture**: New `achronyme-numerical` crate (pure math, no eval dependency)
- **Zero Breaking Changes**: All existing APIs remain unchanged
- **Performance**: Numerical functions execute directly in WASM with minimal overhead

---

## [0.5.0] - 2025-11-04

### Added - Rust WASM Integration & SDK v2.0

**Complete Rewrite with Rust/WASM:**
- **Rust WASM Core** using `wasm-bindgen` with `target=bundler`
- **TypeScript SDK v2.0** with modern architecture:
  - Session-based resource management with automatic cleanup
  - Modular operations: `MathOps`, `DSPOps`, `LinalgOps`, `VectorOps`, `HOFOps`, `StatsOps`
  - Zero-copy value types: `Vector`, `Matrix`, `Scalar`, `Complex`
  - Handle-based memory management with garbage collection
  - Memory pool for efficient handle reuse

**SOC Language Evaluator:**
- Full expression evaluation with `eval()` method
- Lambda functions with closures support
- Higher-order functions: `map`, `filter`, `reduce`, `pipe`
- Variable declarations with `let`
- Complete parser and evaluator in Rust

**Performance Improvements:**
- **5.25x faster** than JavaScript V8 in vectorized math operations
- Optimized vector operations with direct WASM calls (fast-path)
- 10M element operations:
  - `sin()`: 625ms (79.8M ops/sec) vs V8: 3805ms
  - `cos()`: 650ms (76.8M ops/sec) vs V8: 3647ms
  - `exp()`: 754ms (66.2M ops/sec) vs V8: 3417ms

**Interactive Demo:**
- Comprehensive test suite with 8 categories
- Real-time benchmarks vs JavaScript V8 and math.js
- Stress tests (50K vectors, 100K elements, 32K DSP pipeline)
- SOC expression tests with lambdas and HOF

### Changed
- **WASM Build Target**: Changed from `target=web` to `target=bundler` for npm compatibility
- **SDK Architecture**: Refactored to use Rust WASM instead of C++ Emscripten
- **VectorOps Fast-Path**: Now uses direct WASM bindings instead of JavaScript loops (2.6x faster)
- **Import Structure**: Uses compiled artifacts from `dist/` for production

### Fixed
- **Type Safety**: Fixed Float64Array <-> number[] conversions in RustBindings
- **Initialization**: Fixed DOMContentLoaded timing with module scripts
- **Vite Support**: Added `vite-plugin-wasm` and `vite-plugin-top-level-await` for bundler compatibility
- **Memory Management**: `gc()` now returns count of freed handles
- **Package Publishing**: Fixed `.npmignore` to include dist/ properly (55 files, 1.3MB)

### Technical Details
- Rust crates: `achronyme-wasm`, `achronyme-types`, `achronyme-parser`, `achronyme-eval`, `achronyme-dsp`, `achronyme-linalg`
- TypeScript SDK with full type definitions
- Automatic WASM initialization with bundler target
- Enhanced error handling and logging

### Validation
- All SDK tests passing
- All SOC expression tests passing (8/8)
- All benchmarks showing expected performance (5.25x vs V8)
- Package ready for npm publish (verified with `npm pack --dry-run`)
- Interactive demo fully functional
