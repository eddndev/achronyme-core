# Changelog - Version 0.6.x (Unreleased)

All notable changes for the upcoming release will be documented in this file.

## [Unreleased]

### Added - Phase 1 Iterators Complete

**Generators with `yield` and `generate` blocks:**

Achronyme now supports lazy evaluation through generators, enabling efficient processing of large or infinite sequences.

**Generator Syntax:**
```javascript
let counter = generate {
    mut i = 0;
    while (i < 10) {
        yield i;
        i = i + 1
    }
}
```

**Features:**
- **`yield` statement** - Pauses execution and returns a value
- **`generate` blocks** - Creates a generator function
- **State preservation** - Generator state is preserved across yields
- **`return` statement support** - Early termination with sticky done state
- **Environment capture** - Generators capture their lexical environment

**For-in loops with iterator protocol:**
```javascript
let nums = [1, 2, 3, 4, 5]
for (x in nums) {
    print(x * 2)
}
// Output: 2, 4, 6, 8, 10
```

**Generator as iterator:**
```javascript
let fib = generate {
    let a = 0;
    let b = 1;
    while (true) {
        yield a;
        let temp = a;
        a = b;
        b = temp + b
    }
}

// Take first 10 Fibonacci numbers
take(fib, 10)  // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

---

### Added - Generator as Static Type

**Opaque Type in the Type System:**

Generators are now first-class citizens in Achronyme's type system.

**Variable annotations:**
```javascript
let gen: Generator = generate { yield 1; yield 2; yield 3 }
```

**Function signatures:**
```javascript
let processGen: (Generator): Vector = (g) => do {
    let result = [];
    for (x in g) {
        result = push(result, x * 2)
    };
    result
}
```

**Union types:**
```javascript
let maybeGen: Generator | null = null
let activeGen: Generator | null = generate { yield 42 }
```

**Record fields:**
```javascript
let pipeline = {
    source: Generator,
    transform: (Number): Number
}

let data = {
    source: generate { yield 1; yield 2; yield 3 },
    transform: (x) => x * 10
}
```

**Type aliases:**
```javascript
type LazySequence = Generator
type AsyncSource = Generator | null

let seq: LazySequence = generate { yield "a"; yield "b" }
```

**Runtime type checking:**
```javascript
let g = generate { yield 1 }
typeof(g)  // Returns "Generator"
```

---

### Added - Tier 3 Array Transformation Functions

**Comprehensive array manipulation suite:**

#### `zip(array1, array2)` - Combine two arrays into pairs
```javascript
zip([1, 2, 3], ["a", "b", "c"])
// Result: [[1, "a"], [2, "b"], [3, "c"]]

zip([1, 2], [10, 20, 30])
// Result: [[1, 10], [2, 20]]  (stops at shorter array)
```

#### `flatten(array, depth?)` - Flatten nested arrays/tensors
```javascript
flatten([[1, 2], [3, 4]])
// Result: [1, 2, 3, 4]

flatten([[[1, 2]], [[3, 4]]], 1)
// Result: [[1, 2], [3, 4]]

flatten([[[1, 2]], [[3, 4]]], 2)
// Result: [1, 2, 3, 4]

// Infinite depth (default)
flatten([[1, [2, [3, [4]]]]])
// Result: [1, 2, 3, 4]
```

#### `take(array, n)` - Take first n elements
```javascript
take([1, 2, 3, 4, 5], 3)
// Result: [1, 2, 3]

take([1, 2], 10)
// Result: [1, 2]  (returns all if n > length)

// Works with generators
let gen = generate { yield 1; yield 2; yield 3; yield 4; yield 5 }
take(gen, 3)
// Result: [1, 2, 3]
```

#### `drop(array, n)` - Skip first n elements
```javascript
drop([1, 2, 3, 4, 5], 2)
// Result: [3, 4, 5]

drop([1, 2, 3], 10)
// Result: []  (empty if n >= length)
```

#### `slice(array, start, end?)` - Extract subarray
```javascript
slice([1, 2, 3, 4, 5], 1, 4)
// Result: [2, 3, 4]  (indices 1, 2, 3)

slice([1, 2, 3, 4, 5], 2)
// Result: [3, 4, 5]  (from index 2 to end)

slice([1, 2, 3, 4, 5], -2)
// Result: [4, 5]  (last 2 elements)
```

#### `unique(array)` - Remove duplicates
```javascript
unique([1, 2, 2, 3, 3, 3, 4])
// Result: [1, 2, 3, 4]

unique(["a", "b", "a", "c", "b"])
// Result: ["a", "b", "c"]

unique([{x: 1}, {x: 1}, {x: 2}])
// Result: [{x: 1}, {x: 2}]  (by value equality)
```

#### `chunk(array, size)` - Split into groups
```javascript
chunk([1, 2, 3, 4, 5, 6], 2)
// Result: [[1, 2], [3, 4], [5, 6]]

chunk([1, 2, 3, 4, 5], 2)
// Result: [[1, 2], [3, 4], [5]]  (last chunk may be smaller)

chunk([1, 2, 3, 4, 5, 6, 7, 8], 3)
// Result: [[1, 2, 3], [4, 5, 6], [7, 8]]
```

**Use Cases:**
1. **Data processing pipelines** - Chain transformations for ETL operations
2. **Pagination** - `chunk` for batching, `take`/`drop` for page navigation
3. **Deduplication** - `unique` for cleaning data
4. **Parallel processing** - `chunk` to split work across threads
5. **Stream processing** - `take`/`drop` with generators for lazy evaluation
6. **Data reshaping** - `flatten` and `zip` for restructuring

---

### Added - Advanced Type System: Function Types, Edge Types, and Type Aliases

**Complete Gradual Type System with Custom Type Definitions:**

Achronyme now supports a comprehensive type system with first-class function types, edge types for graph programming, and type aliases for creating custom named types.

#### 1. Function Types

Define and enforce function signatures with colon syntax for consistency.

**Syntax:**
```javascript
let func: (ParamTypes): ReturnType = lambda
```

**Features:**
- Parameter type checking at runtime
- Return type enforcement
- Type inference from annotations to lambda parameters
- Higher-order function types
- Currying support

**Examples:**
```javascript
// Simple function type
let add: (Number, Number): Number = (a, b) => a + b

// Type inference - lambda parameters get types from annotation
let multiply: (Number, Number): Number = (a, b) => a * b
// Now a and b are known to be Number without explicit annotation

// Higher-order functions
let compose: ((Number): Number): ((Number): Number): (Number): Number =
    (f) => (g) => (x) => f(g(x))

// Union types in parameters
let process: (Number | String): String = (x) => str(x)

// Any type (opt-out)
let flexible: (Any): Any = (x) => x
```

---

#### 2. Edge Type

Native support for graph edges in the type system.

**Syntax:**
```javascript
let edge: Edge = A -> B      // Directed edge
let edge2: Edge = A <> B     // Undirected edge
```

**Features:**
- Type checking for directed and undirected edges
- Edge metadata support
- Integration with union types for optional edges

**Examples:**
```javascript
// Type-safe edge declarations
let connection: Edge = Server -> Client
let link: Edge = NodeA <> NodeB

// Optional edges
let maybeEdge: Edge | null = null
let activeEdge: Edge | null = A -> B

// Edge with metadata
let weighted: Edge = Start -> End : { weight: 10, label: "path" }
```

---

#### 3. Type Aliases

Create custom named types for better code organization and reusability.

**Syntax:**
```javascript
type AliasName = TypeDefinition
```

**Features:**
- Aliases for any type (simple, union, record, function, tensor)
- Recursive alias resolution
- Chained aliases (alias of alias)
- Full type checking enforcement

**Examples:**
```javascript
// Simple type alias
type ID = Number
let userId: ID = 42

// Record type alias
type Point = { x: Number, y: Number }
let origin: Point = { x: 0, y: 0 }

// Union type alias (optional types)
type OptionalNumber = Number | null
let maybeValue: OptionalNumber = null

// Function type alias
type BinaryOp = (Number, Number): Number
let add: BinaryOp = (a, b) => a + b
let mul: BinaryOp = (a, b) => a * b

// Complex nested structures
type Person = {
    id: ID,
    name: String,
    location: Point
}
let john: Person = {
    id: 1,
    name: "John",
    location: { x: 10, y: 20 }
}

// Result type pattern
type ErrorCode = Number
type Result = String | ErrorCode
let success: Result = "OK"
let error: Result = 404

// Chained aliases
type Integer = Number
type PositiveInt = Integer
let count: PositiveInt = 100

// Mutable variables with type aliases
type Counter = Number
mut counter: Counter = 0
counter = 10  // Type enforced on reassignment

// Tensor type alias
type Matrix = Tensor<Number>
let data: Matrix = [[1, 2], [3, 4]]
```

**Note:** The `type()` function has been renamed to `typeof()` to free the `type` keyword for type aliases.

```javascript
// Old syntax (deprecated)
type(42)  // Error: type is now a keyword

// New syntax
typeof(42)  // Returns "Number"
```

---

#### Type System Summary

| Feature | Syntax | Example |
|---------|--------|---------|
| Simple Types | `Number`, `String`, `Boolean`, `Complex` | `let x: Number = 42` |
| Edge Type | `Edge` | `let e: Edge = A -> B` |
| Generator Type | `Generator` | `let g: Generator = generate {...}` |
| Function Type | `(Params): Return` | `let f: (Number): String = ...` |
| Union Type | `Type1 \| Type2` | `let x: Number \| null = null` |
| Type Alias | `type Name = Type` | `type Point = { x: Number, y: Number }` |
| Any Type | `Any` | `let x: Any = "anything"` |
| Null Type | `null` | Part of union types |

**Tests:** 75 comprehensive type checking integration tests
**Documentation:** `docs/design/type-system-explicit.md`

---

### Added - Control Flow Enhancements: if-else Statements & Early Returns

**Complete Control Flow System:**

Since version 0.1.0, Achronyme now supports modern imperative control flow constructs alongside its functional programming features.

#### 1. if-else Statement Syntax (Block Form)

Traditional imperative-style if-else statements with multi-statement blocks.

**Syntax:**
```javascript
if (condition) {
    statement1;
    statement2;
    result
} else if (condition2) {
    statement3;
    result2
} else {
    statement4;
    result3
}
```

**Key Features:**
- Multi-statement blocks without `do` keyword
- else-if chains supported
- Returns last expression in block
- No `do` required (unlike lambda blocks)

**Example:**
```javascript
let processValue = (x) => if (x < 0) {
    print("Processing negative:", x);
    let abs = -x;
    abs * 2
} else {
    print("Processing positive:", x);
    x * 2
}
```

**Documentation:** `docs/language/08-control-flow.md`
**Examples:** `examples/soc/39-if-else-complete.soc` (10 comprehensive examples)

---

#### 2. return Statement (Early Return)

Early exit from functions with explicit return values.

**Syntax:**
```javascript
return value
```

**Key Features:**
- Immediately exits current function
- Stops execution of subsequent code
- Works in if-else blocks, do blocks, and anywhere inside functions
- Perfect for guard clauses and validation patterns

**Guard Clauses Pattern:**
```javascript
// Without return (nested)
let process = (data) => do {
    if (len(data) > 0) {
        if (sum(data) > 0) {
            mean(data)
        } else {
            0
        }
    } else {
        0
    }
}

// With return (cleaner)
let processClean = (data) => do {
    if (len(data) == 0) {
        return 0
    };
    if (sum(data) <= 0) {
        return 0
    };
    mean(data)
}
```

**Return in Recursive Functions:**
```javascript
// Binary search with early return
let binarySearch = (arr, target, left, right) => do {
    if (left > right) {
        return -1
    };

    let mid = floor((left + right) / 2);

    if (arr[mid] == target) {
        return mid
    };

    if (arr[mid] > target) {
        return rec(arr, target, left, mid - 1)
    };

    rec(arr, target, mid + 1, right)
}

let search = (arr, target) => binarySearch(arr, target, 0, len(arr) - 1)
```

**Documentation:** `docs/language/08-control-flow.md`
**Examples:** `examples/soc/40-return-statement.soc` (10 comprehensive examples)

---

#### Syntax Differences Summary

**if-else blocks:** Multi-statements supported directly (NO `do` needed)
```javascript
if (x > 0) {
    let doubled = x * 2;
    doubled + 1
} else {
    0
}
```

**Lambda blocks:** Multi-statements require `do` keyword
```javascript
map((x) => do {
    let doubled = x * 2;
    doubled + 1
}, data)
```

**Key Distinction:**
- if-else: `{ stmt1; stmt2; result }` - No `do`
- Lambda: `(x) => do { stmt1; stmt2; result }` - `do` required

---

### Added - Module System, Mutability, and Do Blocks

**Complete Module System:**
- **`import` Statement**: Import functionality from built-in or user-defined modules.
  - `import { mean, std } from "stats"`
  - `import { double } from "src/utils"`
- **`export` Statement**: Export functions and values from a module.
  - `export { myFunction, myValue }`
- **Built-in Modules**: `stats`, `math`, `linalg`.
- **User-Defined Modules**: Create reusable `.soc` files.
- **Module Resolution**: Relative paths from the importing file.

**Mutability:**
- **`mut` Keyword**: Declare mutable variables and record fields.
  - `mut counter = 0`
  - `let config = { mut value: 10 }`
- **Reassignment**: Mutable variables can be reassigned using `=`.
  - `counter = counter + 1`
  - `config.value = 20`
- **Stateful Objects**: Create objects with methods that mutate internal state via `self`.
  ```javascript
  let counter = {
      mut value: 0,
      increment: () => do { self.value = self.value + 1 }
  }
  ```

**Do Blocks:**
- **`do { ... }` Syntax**: Group multiple statements into a single expression.
- **Local Scope**: `let` bindings inside `do` are local.
- **Return Value**: The value of the last expression is returned.
  ```javascript
  let result = do {
      let x = 5;
      let y = 10;
      x + y  // Returns 15
  }
  ```

**Breaking Changes:**
- `import`, `export`, `from`, `as`, `mut` are now reserved keywords.

---

### Added - Environment I/O and Persistence

**Complete Environment Serialization:**
- **`save_env()`**: Save the current REPL environment to a compressed `.ach` file.
  - `save_env("my_session.ach")`
  - Advanced options: filtering, compression level, metadata.
- **`restore_env()`**: Load an environment from a file.
  - `restore_env("my_session.ach")`
  - Modes: `merge` (default), `replace`, `namespace`.
- **`env_info()`**: Inspect metadata of an `.ach` file without loading.
  - `env_info("my_session.ach")` -> `{ created_at, num_bindings, ... }`
- **`.ach` File Format**:
  - Custom binary format with versioning.
  - Zstd compression and SHA-256 checksums for integrity.
  - MessagePack serialization for cross-platform compatibility.

---

### Added - Graph Theory & PERT/CPM Analysis

**Comprehensive Graph Algorithm Suite:**
- **Graph Construction**: `network()` with `->` (directed) and `<>` (undirected) edge syntax.
- **Traversal**: `bfs`, `dfs`, `bfs_path`.
- **Shortest Path**: `dijkstra` for weighted graphs.
- **Minimum Spanning Tree**: `kruskal`, `prim`.
- **Topological Sort**: `topological_sort` for DAGs.
- **Cycle Detection**: `has_cycle`.
- **Connectivity**: `is_connected`, `connected_components`.

**Full PERT/CPM Project Management Suite:**
- **Critical Path Method**: `forward_pass`, `backward_pass`, `calculate_slack`, `critical_path`, `project_duration`.
- **Probabilistic PERT**: `expected_time`, `task_variance`, `project_variance`, `completion_probability`, `time_for_probability`.
- **Complete Analysis**: `pert_analysis` for one-stop project overview.

---

### Added - Expanded Standard Library

**New String Functions:**
- **Case Conversion**: `upper()`, `lower()`.
- **Whitespace**: `trim()`, `trim_start()`, `trim_end()`.
- **Searching**: `starts_with()`, `ends_with()`, `contains()`.
- **Manipulation**: `replace()`, `split()`, `join()`.
- **Padding**: `pad_start()`, `pad_end()`.
- **Operator**: `+` for string concatenation.

**New Array & Utility Functions:**
- **Utilities**: `print()`, `type()`, `str()`.
- **Array Creation**: `range()`.
- **Array Operations**: `product()`, `reverse()`.
- **Predicate Functions**: `any()`, `all()`, `find()`, `findIndex()`, `count()`.

**Linear Algebra Decompositions:**
- **Decompositions**: `lu`, `qr`, `cholesky`, `svd`.
- **Eigenvalue Solvers**: `eigenvalues`, `eigenvectors`, `power_iteration`.

---

### Added - Tensor Indexing & Slicing

**Complete N-Dimensional Tensor Indexing:**

- **Single Element Access**
  - Access individual elements using bracket notation: `tensor[i, j, k]`
  - Supports negative indexing (Python-style): `v[(-1)]` accesses last element
  - Works with vectors (1D), matrices (2D), and N-dimensional tensors

- **Range Slicing**
  - Extract sub-tensors using range notation: `start..end`, `start..`, `..end`, `..`
  - Reduces dimensionality when slicing

- **Mixed Indexing & Slicing**
  - Combine single indices and ranges: `tensor[0, .., 1..3]`

- **String Indexing & Slicing**
  - Same syntax works for strings

**Known Limitations:**
- **Negative Index Syntax**: Requires parentheses for literals: `v[(-1)]`

---

### Added - Recursive Functions & Self-Reference System

**`rec` - Magic Self-Reference for Recursion:**
- Automatic self-reference in any function without naming
- Works in named and anonymous functions
- No dependency on variable names

**Fixed `self` - Self-Reference in Records:**
- Record methods with `self` now work correctly
- Methods can access record fields and call other methods

**Lambdas Without Parameters `() =>`:**
- Zero-parameter lambda support
- Useful for getters, constants, lazy evaluation

**IIFE (Immediately Invoked Function Expressions):**
- Full IIFE support: `(lambda)(args)`

---

### Added - Tensor Broadcasting & Scalar Operations

**Complete Tensor-Scalar Broadcasting Implementation:**
- Scalar arithmetic methods for `RealTensor` and `ComplexTensor`
- Binary operations broadcasting: `Tensor +/- Number`, `Number +/- Tensor`
- Automatic type promotion

---

### Changed - Tensor Migration Complete

**Legacy Matrix/Vector Types Eliminated:**
- Unified grammar & parser with single `array` rule
- Unified AST with `AstNode::ArrayLiteral`
- Automatic N-dimensional tensor creation

---

### Added - String & Record Types

**String Type Implementation:**
- First-class string support with full Unicode
- String functions: `concat()`, `length()`, comparisons

**Record Type Implementation:**
- Key-value data structures
- Field access syntax with dot notation
- Record functions: `keys()`, `values()`, `has_field()`

**REPL Enhancement: Multi-line Expression Support**

---

### Added - Complex Numbers & Complex Vectors

**Complex Number System Enhanced:**
- Complex^Complex power operation
- Imaginary unit constant `i`

**New `ComplexVector` Type:**
- Native complex vector support
- Type promotion system

**DSP Functions Modernized:**
- `fft()` returns `ComplexVector`
- `ifft()` accepts `ComplexVector`

---

### Added - Variable Shadowing & Scope System

**Stack-Based Scope System:**
- Variable shadowing in lambdas
- Let redeclaration (shadowing in same scope)
- Closures preserved

---

### Refactoring - Evaluator Architecture

**Code Organization Improvements:**
- Evaluator reduced from 1179 to 203 lines (83% reduction)
- Logic separated into specialized handlers

---

### Known Limitations

**Variable Scoping:**
- No variable reassignment without `mut` (by design)
- Use shadowing for immutable transformation patterns

---

### Planned Features (Phase 5+)
- Symbolic computation
- Units and dimensions
- Ordinary Differential Equations (ODEs)
- Nonlinear optimization (gradient descent, conjugate gradient, BFGS)
- Constrained optimization (SQP, barrier methods)
